#include "FirstIncludes.h"
#include <stdio.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include "MemoryDebug.h"
using namespace  std;

#include "KKBaseTypes.h"
#include "KKException.h"
#include "OSservices.h"
using namespace  KKB;

#include "ClassAssignments.h"
#include "MLClass.h"
using namespace  KKMLL;



ClassAssignments::ClassAssignments ():
    multimap<kkint32, MLClassPtr> ()
{
}



ClassAssignments::ClassAssignments (const MLClassList&  classes):
    multimap<kkint32, MLClassPtr> ()
{
  kkint32  x = 0;
  for  (MLClassList::const_iterator idx = classes.begin ();  idx != classes.end ();  idx++)
  {
   insert (pair<kkint32, MLClassPtr> (x, *idx));
   classLookUp.insert (pair<MLClassPtr, kkint32> (*idx, x));
   x++;
  }
}



kkMemSize  ClassAssignments::MemoryConsumedEstimated ()  const
{
  kkMemSize  memoryConsumedEstimated = sizeof (ClassAssignments) 
    +  (classLookUp.size () * (sizeof (MLClassPtr) + sizeof (kkint32)));
  return  memoryConsumedEstimated;
}



void  ClassAssignments::AddMLClass (MLClassPtr  mlClass,
                                    kkint32     num,
                                    RunLog&     log
                                   )
{
  ClassLookUpIterator  idx;
  idx = classLookUp.find (mlClass);
  if  (idx != classLookUp.end ())
  {
    log.Level (-1) << endl << endl 
                   << "ClassAssignments::AddMLClass     ***ERROR***       Duplicate Class Being Added[" << mlClass->Name () <<  "]." << endl
                   << "              Num Found           [" << idx->second << "]" << endl
                   << "              New Num Being Added [" << num         << endl
                   << endl;
    return;
  }

  insert (pair<kkint32, MLClassPtr> (num, mlClass));
  classLookUp.insert (pair<MLClassPtr, kkint32> (mlClass, num));
}  /* AddMLClass */



MLClassPtr  ClassAssignments::GetMLClass (kkint32 num)  const
{
  multimap<kkint32, MLClassPtr>::const_iterator p;
  p = find (num);
  if  (p == end ())
    return NULL;
  return p->second;
}  /* GetMLClass */



MLClassList  ClassAssignments::GetMLClasses (kkint32 num)  const
{
  ClassAssignments::const_iterator  idx;

  MLClassList  results;
  for  (idx = begin ();  idx != end ();  idx++)
  {
    if  (idx->first == num)
      results.PushOnBack (idx->second);
  }

  return  results;
}  /* GetMLClasses */



VectorInt32  ClassAssignments::GetUniqueListOfAssignments ()  const
{
  VectorInt32  nums;

  ClassAssignments::const_iterator  idx;

  for  (idx = begin ();  idx != end ();  idx++)
  {
    nums.push_back (idx->first);
  }

  sort (nums.begin (), nums.end ());

  KKB::VectorInt32 results;

  kkint32  lastNum = -999;
  VectorInt32::const_iterator  idx2;
  for  (idx2 = nums.begin (); idx2 != nums.end ();  ++idx2)
  {
    if  (*idx2 != lastNum)
    {
      lastNum = *idx2;
      results.push_back (lastNum);
    }
  }

  return  results;
}  /* GetUniqueListOfAssignments */



MLClassPtr  ClassAssignments::GetMLClassByIndex (kkint32 idx)
{
  if  ((idx < 0)  ||  (idx >= (kkint32)size ()))
  {
    cerr << endl
         << endl
         << "ClassAssignments::GetMLClassByIndex   *** ERROR ***" << endl
         << "                                        idx[" << idx << "] is out of range." << endl
         << endl;
    return NULL;
  }

  iterator i = begin ();
  for  (kkint32 x = 0; x < idx;  ++x)
    i++;

  return i->second;
}  /* GetMLClassByIndex */



OptionUInt32  ClassAssignments::GetNumForClass (MLClassPtr  mlClass)  const
{
  ClassLookUp::const_iterator  idx;
  idx = classLookUp.find (mlClass);
  if  (idx == classLookUp.end ())
    return {};
  else
    return idx->second;
}  /* GetNumForClass */



void  ClassAssignments::Save (const KKStr&  fileName,
                              bool&          successful
                             )
{
  ofstream outFile (fileName.Str ());

  for  (iterator  idx = begin (); idx != end ();  idx++)
  {
    outFile << idx->second->Name () << "\t" << idx->first << endl;
  }

  successful = true;
  return;
}



KKStr  ClassAssignments::ToString ()  const
{
  KKStr  result ((kkint32)(size () * 20));

  result << kkint32 (size ());

  ClassAssignments::const_iterator idx;
  for (idx = begin ();  idx != end ();  idx++)
  {
    result << "\t" << idx->first << "\t" << idx->second->Name ();
  }

  return  result;
}  /* ToString */



/**
* @brief Loads class assignments from string that was originally generated by ToString
* @param[in] _toString,  KKStr containing class assignments info, will expect to be formated
*                        the way ToString() creates them.
*/
void   ClassAssignments::ParseToString (const KKStr&  _toString,
                                        RunLog&       _log
                                       )
{
  erase (begin (), end ());

  KKStr toString (_toString);

  // Remove Class count from string
  toString.ExtractTokenInt ("\t\n\r");

  while  (!toString.Empty ())
  {
    kkint32 assignmentNum = toString.ExtractTokenInt ("\t\n\r");
    KKStr  className = toString.ExtractToken ("\t\n\r");

    if  (!className.Empty ())
    {
      MLClassPtr  mlClass = MLClass::CreateNewMLClass (className);
      AddMLClass (mlClass, assignmentNum, _log);
    }
  }
}  /* ParseToString */
