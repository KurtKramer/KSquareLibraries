\hypertarget{class_k_k_b_1_1_k_k_queue}{}\section{K\+KB\+:\+:K\+K\+Queue$<$ Entry $>$ Class Template Reference}
\label{class_k_k_b_1_1_k_k_queue}\index{K\+K\+B\+::\+K\+K\+Queue$<$ Entry $>$@{K\+K\+B\+::\+K\+K\+Queue$<$ Entry $>$}}


A typed container class/template that keeps track of entries via pointers only.  




{\ttfamily \#include $<$K\+K\+Queue.\+h$>$}

Inheritance diagram for K\+KB\+:\+:K\+K\+Queue$<$ Entry $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{class_k_k_b_1_1_k_k_queue}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ Entry $\ast$ $>$\+::\hyperlink{class_k_k_b_1_1_k_k_queue_aeb057c9c010446f46f57c1e355f981f1}{const\+\_\+iterator} \hyperlink{class_k_k_b_1_1_k_k_queue_aeb057c9c010446f46f57c1e355f981f1}{const\+\_\+iterator}
\item 
typedef std\+::vector$<$ Entry $\ast$ $>$\+::\hyperlink{class_k_k_b_1_1_k_k_queue_aa3c2796a726eea468b94132a9fbf2cfe}{iterator} \hyperlink{class_k_k_b_1_1_k_k_queue_aa3c2796a726eea468b94132a9fbf2cfe}{iterator}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_k_k_b_1_1_k_k_queue_ac3a8d94136981f1db9ae5a9d591a0008}{K\+K\+Queue} (bool \+\_\+owner=true)
\item 
\hyperlink{class_k_k_b_1_1_k_k_queue_a1b5f9f1225f00bc6932d30028319ead6}{K\+K\+Queue} (const \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} \&q, bool \+\_\+owner)
\begin{DoxyCompactList}\small\item\em Constructor, similar to the Copy Constructor except that you can control whether it duplicates the contents. \end{DoxyCompactList}\item 
virtual \hyperlink{class_k_k_b_1_1_k_k_queue_a4fe8349c9b1a9c2e203611a10fcdbb2f}{$\sim$\+K\+K\+Queue} ()
\begin{DoxyCompactList}\small\item\em Virtual destructor; if owns its contents will also call the destructor on each one entry that it contains. \end{DoxyCompactList}\item 
virtual void \hyperlink{class_k_k_b_1_1_k_k_queue_adec987ebb0ac593ad877ffa59becb107}{Add} (Entry\+Ptr \+\_\+entry)
\item 
virtual void \hyperlink{class_k_k_b_1_1_k_k_queue_a1832186a944dca6fb3d5fca4046b7c40}{Add\+First} (Entry\+Ptr \+\_\+entry)
\item 
virtual void \hyperlink{class_k_k_b_1_1_k_k_queue_aefa1334998f59c7184911b47addccee3}{Add\+Queue} (const \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} \&q)
\begin{DoxyCompactList}\small\item\em Add the contents of a separate \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} container to this container. \end{DoxyCompactList}\item 
Entry\+Ptr \hyperlink{class_k_k_b_1_1_k_k_queue_a9c3fadab17ce05dc750d96b6d3fad064}{Back\+Of\+Queue} () const 
\item 
void \hyperlink{class_k_k_b_1_1_k_k_queue_a72dbe1e65d567536dbf4be3617230254}{Delete\+Contents} ()
\item 
void \hyperlink{class_k_k_b_1_1_k_k_queue_ae362e3b0a128e8a09182e167befda088}{Delete\+Entry} (Entry\+Ptr \+\_\+entry)
\item 
void \hyperlink{class_k_k_b_1_1_k_k_queue_acc76c23f4e4e1ecddd5c82619a93d4b2}{Delete\+Entry} (\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} \+\_\+idx)
\item 
\hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} $\ast$ \hyperlink{class_k_k_b_1_1_k_k_queue_acc09d961e9f995ccf6183ff1a5e87e23}{Duplicate\+List\+And\+Contents} () const 
\begin{DoxyCompactList}\small\item\em Creates a new container including duplicating the contents, which also makes the new instance the owner of those contents. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Functor $>$ }\\\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} \hyperlink{class_k_k_b_1_1_k_k_queue_a0cc98856d9a20f8838bd647e0391e6b2}{Find\+The\+Kth\+Element} (\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} k, Functor pred)
\item 
Entry\+Ptr \hyperlink{class_k_k_b_1_1_k_k_queue_af449cfe0b0d33b6623949be7b7dc1103}{Front\+Of\+Queue} () const 
\item 
Entry\+Ptr \hyperlink{class_k_k_b_1_1_k_k_queue_ad194def66421c09375d6c9c900a4c6d6}{Get\+First} () const 
\item 
Entry\+Ptr \hyperlink{class_k_k_b_1_1_k_k_queue_a8cd2a0f6218ce6f63cba5c0dacf97fdf}{Get\+Last} () const 
\item 
Entry\+Ptr \hyperlink{class_k_k_b_1_1_k_k_queue_acce2bdd8b3327e38266cf198382cd852}{Idx\+To\+Ptr} (\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} idx) const 
\item 
\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32} \hyperlink{class_k_k_b_1_1_k_k_queue_a7605c8e51c5b1c5182482dab8226e4bc}{Locate\+Entry} (Entry\+Const\+Ptr \+\_\+entry) const 
\item 
Entry\+Ptr \hyperlink{class_k_k_b_1_1_k_k_queue_a7d818f2e1710a314f2bba035fe86dd41}{Look\+At\+Back} () const 
\item 
Entry\+Ptr \hyperlink{class_k_k_b_1_1_k_k_queue_a33e29d962c414c890db00f8c25224a82}{Look\+At\+Front} () const 
\item 
bool \hyperlink{class_k_k_b_1_1_k_k_queue_a5960ccd8db282fcb7955852e755baa14}{operator!=} (const \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue}$<$ Entry $>$ \&right\+Side) const 
\begin{DoxyCompactList}\small\item\em returns False if N\+OT every entry in both containers point to the same elements \end{DoxyCompactList}\item 
\hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} \& \hyperlink{class_k_k_b_1_1_k_k_queue_ac1e30c66658adfcd502af08d177af7da}{operator=} (const \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} \&q)
\begin{DoxyCompactList}\small\item\em Assignment Operator. \end{DoxyCompactList}\item 
bool \hyperlink{class_k_k_b_1_1_k_k_queue_a93ba7b2058bef5c355f003fe3bdbcab6}{operator==} (const \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue}$<$ Entry $>$ \&right\+Side) const 
\begin{DoxyCompactList}\small\item\em Returns True if every entry in both containers point to the same elements. \end{DoxyCompactList}\item 
Entry \& \hyperlink{class_k_k_b_1_1_k_k_queue_a8c2edf92ac57e26fe47032ad4d92f165}{operator\mbox{[}$\,$\mbox{]}} (\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} i) const 
\item 
bool \hyperlink{class_k_k_b_1_1_k_k_queue_a4990d037ff09dd504cc7df53819bf61a}{Owner} () const 
\item 
void \hyperlink{class_k_k_b_1_1_k_k_queue_aaf47f5cb6057e35b9f0d230b8b9a3906}{Owner} (bool \+\_\+owner)
\item 
virtual Entry\+Ptr \hyperlink{class_k_k_b_1_1_k_k_queue_a03844c19a838fed7e7bcc5816846dcfd}{Pop\+From\+Back} ()
\item 
virtual Entry\+Ptr \hyperlink{class_k_k_b_1_1_k_k_queue_a2b2205f34516ac1f2950f441625d3ec7}{Pop\+From\+Front} ()
\item 
\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32} \hyperlink{class_k_k_b_1_1_k_k_queue_ac7c26abdf599669a4b0898534f735f99}{Ptr\+To\+Idx} (Entry\+Const\+Ptr \+\_\+entry) const 
\item 
virtual void \hyperlink{class_k_k_b_1_1_k_k_queue_aa9fba4632b54268bf71ecb42dee0b575}{Push\+On\+Back} (Entry\+Ptr \+\_\+entry)
\item 
virtual void \hyperlink{class_k_k_b_1_1_k_k_queue_a07b83a99241a167f7a395a40d32f6380}{Push\+On\+Front} (Entry\+Ptr \+\_\+entry)
\item 
\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32} \hyperlink{class_k_k_b_1_1_k_k_queue_a1dab601f75ee6a65d97f02bddf71c40d}{Queue\+Size} () const 
\item 
void \hyperlink{class_k_k_b_1_1_k_k_queue_ab43920c3ec182b87d3affa1e1611e1b0}{Randomize\+Order} ()
\begin{DoxyCompactList}\small\item\em Randomizes the order of the vector. \end{DoxyCompactList}\item 
void \hyperlink{class_k_k_b_1_1_k_k_queue_a72f950cfa2e3482aa8c527eb024a57ee}{Randomize\+Order} (\hyperlink{namespace_k_k_b_aa3486b1c5ea9162b3b020c69f72826eb}{kkint64} seed)
\item 
void \hyperlink{class_k_k_b_1_1_k_k_queue_af9fd71e0f10f8383153eecbbbfce0f30}{Randomize\+Order} (\hyperlink{class_k_k_b_1_1_random_num_generator}{Random\+Num\+Generator} \&random\+Variable)
\begin{DoxyCompactList}\small\item\em Randomizes the order of the vector. \end{DoxyCompactList}\item 
virtual Entry\+Ptr \hyperlink{class_k_k_b_1_1_k_k_queue_a667988c7ff02753f1324fb6c52debf84}{Remove\+First} ()
\item 
virtual Entry\+Ptr \hyperlink{class_k_k_b_1_1_k_k_queue_ae25cc5a483346ddf4231ae30d29f0b2e}{Remove\+Last} ()
\item 
void \hyperlink{class_k_k_b_1_1_k_k_queue_a3f72bf16ba59d4269ecf5db9fad9ef9e}{Set\+Idx\+To\+Ptr} (\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} \+\_\+idx, Entry $\ast$\+\_\+ptr)
\item 
void \hyperlink{class_k_k_b_1_1_k_k_queue_a7a848286a5d2ddd9b0d320557a458f66}{Swap\+Indexes} (size\+\_\+t idx1, size\+\_\+t idx2)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_k_k_b_1_1_k_k_queue_ab21be04f42eefbaed9c718f32029a812}{K\+K\+Queue} (const \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} \&q)
\begin{DoxyCompactList}\small\item\em Copy Constructor creating new instance; including duplicating contents if owner set to true. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$class Entry$>$\\*
class K\+K\+B\+::\+K\+K\+Queue$<$ Entry $>$}

A typed container class/template that keeps track of entries via pointers only. 

Will act as an Array, Queue or Stack structure. Items are added by the \textquotesingle{}Push\+On\+Front\textquotesingle{} and \textquotesingle{}Push\+On\+Back\textquotesingle{} methods. They are removed by the \textquotesingle{}Pop\+From\+Front\textquotesingle{} and \textquotesingle{}Pop\+From\+Back\textquotesingle{} methods. What is important to keep in mind is that it holds pointers to its contents, not the actual instances. It is important to keep track who owns the objects you put in an instance of \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue}. \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} has a \textquotesingle{}Owner\textquotesingle{} flag that you can set. If it is set to \textquotesingle{}true\textquotesingle{} then it will call the destructor on all its contents when you call \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue}\textquotesingle{}s destructor or the \textquotesingle{}Destroy\+Contents\textquotesingle{} method. When you add an element to a \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} container you can not delete it separately until you either remove it from \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} or delete the \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} container. If the \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} derived container owned its contents and you call its destructor then there is no need to delete the contents separately.

\hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} is sub-\/classed from vector$<$\+Entry$\ast$$>$ so you can use any method that is available for the vector$<$$>$ template.


\begin{DoxyTemplParams}{Template Parameters}
{\em Entry} & The type of objects that are to be held in this container. When you add new instances of \textquotesingle{}Entry\textquotesingle{}, you need to add a pointer to it not the actual entry. \\
\hline
\end{DoxyTemplParams}


Definition at line 77 of file K\+K\+Queue.\+h.



\subsection{Member Typedef Documentation}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!const\+\_\+iterator@{const\+\_\+iterator}}
\index{const\+\_\+iterator@{const\+\_\+iterator}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{const\+\_\+iterator}{const_iterator}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry$>$ typedef std\+::vector$<$Entry$\ast$$>$\+::{\bf const\+\_\+iterator} {\bf K\+K\+B\+::\+K\+K\+Queue}$<$ Entry $>$\+::{\bf const\+\_\+iterator}}\hypertarget{class_k_k_b_1_1_k_k_queue_aeb057c9c010446f46f57c1e355f981f1}{}\label{class_k_k_b_1_1_k_k_queue_aeb057c9c010446f46f57c1e355f981f1}


Definition at line 89 of file K\+K\+Queue.\+h.

\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!iterator@{iterator}}
\index{iterator@{iterator}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{iterator}{iterator}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry$>$ typedef std\+::vector$<$Entry$\ast$$>$\+::{\bf iterator} {\bf K\+K\+B\+::\+K\+K\+Queue}$<$ Entry $>$\+::{\bf iterator}}\hypertarget{class_k_k_b_1_1_k_k_queue_aa3c2796a726eea468b94132a9fbf2cfe}{}\label{class_k_k_b_1_1_k_k_queue_aa3c2796a726eea468b94132a9fbf2cfe}


Definition at line 88 of file K\+K\+Queue.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!K\+K\+Queue@{K\+K\+Queue}}
\index{K\+K\+Queue@{K\+K\+Queue}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{K\+K\+Queue(bool \+\_\+owner=true)}{KKQueue(bool _owner=true)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ K\+K\+Queue\+::\+K\+K\+Queue (
\begin{DoxyParamCaption}
\item[{bool}]{\+\_\+owner = {\ttfamily true}}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_k_k_queue_ac3a8d94136981f1db9ae5a9d591a0008}{}\label{class_k_k_b_1_1_k_k_queue_ac3a8d94136981f1db9ae5a9d591a0008}


Definition at line 219 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
219                                       :
220       owner (\_owner)
221   \{
222   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!K\+K\+Queue@{K\+K\+Queue}}
\index{K\+K\+Queue@{K\+K\+Queue}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{K\+K\+Queue(const K\+K\+Queue \&q)}{KKQueue(const KKQueue &q)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ K\+K\+Queue\+::\+K\+K\+Queue (
\begin{DoxyParamCaption}
\item[{const {\bf K\+K\+Queue}$<$ Entry $>$ \&}]{q}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{class_k_k_b_1_1_k_k_queue_ab21be04f42eefbaed9c718f32029a812}{}\label{class_k_k_b_1_1_k_k_queue_ab21be04f42eefbaed9c718f32029a812}


Copy Constructor creating new instance; including duplicating contents if owner set to true. 

If the parameter \textquotesingle{}q\textquotesingle{} owns its contents then will create new instances of its contents. That is it will call the Copy Constructor for each one of the elements it contains. If \textquotesingle{}q\textquotesingle{} does not own its contents it will just copy over the pointers from \textquotesingle{}q\textquotesingle{}, meaning that the new instance of \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} will point to the same locations as \textquotesingle{}q\textquotesingle{} does. 

Definition at line 227 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
227                                            :
228         owner (q.Owner ())
229 
230   \{
231     \textcolor{comment}{//for  (vector<Entry*>::const\_iterator x = q.begin ();  x != q.end ();  x++)}
232     \textcolor{keywordflow}{for}  (\hyperlink{class_k_k_b_1_1_k_k_queue_aeb057c9c010446f46f57c1e355f981f1}{const\_iterator} x = q.begin ();  x != q.end ();  x++)
233     \{
234       \textcolor{keywordflow}{if}  (owner)
235         \hyperlink{class_k_k_b_1_1_k_k_queue_aa9fba4632b54268bf71ecb42dee0b575}{PushOnBack} (\textcolor{keyword}{new} Entry (*(*x)));
236       \textcolor{keywordflow}{else}
237         \hyperlink{class_k_k_b_1_1_k_k_queue_aa9fba4632b54268bf71ecb42dee0b575}{PushOnBack} (*x); 
238     \}
239   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!K\+K\+Queue@{K\+K\+Queue}}
\index{K\+K\+Queue@{K\+K\+Queue}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{K\+K\+Queue(const K\+K\+Queue \&q, bool \+\_\+owner)}{KKQueue(const KKQueue &q, bool _owner)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ K\+K\+Queue\+::\+K\+K\+Queue (
\begin{DoxyParamCaption}
\item[{const {\bf K\+K\+Queue}$<$ Entry $>$ \&}]{q, }
\item[{bool}]{\+\_\+owner}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_k_k_queue_a1b5f9f1225f00bc6932d30028319ead6}{}\label{class_k_k_b_1_1_k_k_queue_a1b5f9f1225f00bc6932d30028319ead6}


Constructor, similar to the Copy Constructor except that you can control whether it duplicates the contents. 

If the \textquotesingle{}\+\_\+owner\textquotesingle{} parameter is set to true then it will create new instances of the contents otherwise it will just point to the instances that already exist. 

Definition at line 243 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
245                            :
246         owner (\_owner)
247 
248   \{
249     \textcolor{comment}{//for  (vector<Entry*>::const\_iterator x = q.begin}
250     \textcolor{comment}{//  owner (\_owner) ();  x != q.end ();  x++)}
251     \textcolor{keywordflow}{for}  (\hyperlink{class_k_k_b_1_1_k_k_queue_aeb057c9c010446f46f57c1e355f981f1}{const\_iterator} x = q.begin ();  x != q.end ();  ++x)
252     \{
253       \textcolor{keywordflow}{if}  (owner)
254         \hyperlink{class_k_k_b_1_1_k_k_queue_aa9fba4632b54268bf71ecb42dee0b575}{PushOnBack} (\textcolor{keyword}{new} Entry (*(*x)));
255       \textcolor{keywordflow}{else}
256         \hyperlink{class_k_k_b_1_1_k_k_queue_aa9fba4632b54268bf71ecb42dee0b575}{PushOnBack} (*x); 
257     \}
258   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!````~K\+K\+Queue@{$\sim$\+K\+K\+Queue}}
\index{````~K\+K\+Queue@{$\sim$\+K\+K\+Queue}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{$\sim$\+K\+K\+Queue()}{~KKQueue()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ K\+K\+Queue\+::$\sim$\+K\+K\+Queue (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{class_k_k_b_1_1_k_k_queue_a4fe8349c9b1a9c2e203611a10fcdbb2f}{}\label{class_k_k_b_1_1_k_k_queue_a4fe8349c9b1a9c2e203611a10fcdbb2f}


Virtual destructor; if owns its contents will also call the destructor on each one entry that it contains. 



Definition at line 280 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
281   \{
282     \textcolor{keywordflow}{if}  (owner)
283     \{
284       \hyperlink{class_k_k_b_1_1_k_k_queue_aa3c2796a726eea468b94132a9fbf2cfe}{iterator}  i;
285 
286       \textcolor{keywordflow}{for}  (i = KKQueue<Entry>::begin ();  i != KKQueue<Entry>::end (); i++)
287       \{
288         \textcolor{keyword}{delete} *i;
289         *i = NULL;
290       \}
291     \}
292   \}  \textcolor{comment}{/* ~KKQueue */}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Add@{Add}}
\index{Add@{Add}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Add(\+Entry\+Ptr \+\_\+entry)}{Add(EntryPtr _entry)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ void K\+K\+Queue\+::\+Add (
\begin{DoxyParamCaption}
\item[{Entry\+Ptr}]{\+\_\+entry}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{class_k_k_b_1_1_k_k_queue_adec987ebb0ac593ad877ffa59becb107}{}\label{class_k_k_b_1_1_k_k_queue_adec987ebb0ac593ad877ffa59becb107}
same as Push\+On\+Back 

Definition at line 339 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
340   \{
341     \hyperlink{class_k_k_b_1_1_k_k_queue_aa9fba4632b54268bf71ecb42dee0b575}{PushOnBack} (\_entry);
342   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Add\+First@{Add\+First}}
\index{Add\+First@{Add\+First}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Add\+First(\+Entry\+Ptr \+\_\+entry)}{AddFirst(EntryPtr _entry)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ void K\+K\+Queue\+::\+Add\+First (
\begin{DoxyParamCaption}
\item[{Entry\+Ptr}]{\+\_\+entry}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{class_k_k_b_1_1_k_k_queue_a1832186a944dca6fb3d5fca4046b7c40}{}\label{class_k_k_b_1_1_k_k_queue_a1832186a944dca6fb3d5fca4046b7c40}
same as Push\+On\+Front 

Definition at line 347 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
348   \{
349     \hyperlink{class_k_k_b_1_1_k_k_queue_a07b83a99241a167f7a395a40d32f6380}{PushOnFront} (\_entry);
350   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Add\+Queue@{Add\+Queue}}
\index{Add\+Queue@{Add\+Queue}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Add\+Queue(const K\+K\+Queue \&q)}{AddQueue(const KKQueue &q)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ void K\+K\+Queue\+::\+Add\+Queue (
\begin{DoxyParamCaption}
\item[{const {\bf K\+K\+Queue}$<$ Entry $>$ \&}]{q}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{class_k_k_b_1_1_k_k_queue_aefa1334998f59c7184911b47addccee3}{}\label{class_k_k_b_1_1_k_k_queue_aefa1334998f59c7184911b47addccee3}


Add the contents of a separate \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} container to this container. 

Be careful how the Owner flags are set; this method adds the pointers of \textquotesingle{}q\textquotesingle{} to the end of its own container; it does not concern itself with the state of the \textquotesingle{}Owner\textquotesingle{} flags. If you are not careful you can have both containers thinking they own the same entries. I suggest that after you add the contents of \textquotesingle{}q\textquotesingle{} to this container that the caller set the \textquotesingle{}owner\textquotesingle{} flag of \textquotesingle{}q\textquotesingle{} to false. 

Definition at line 355 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
356   \{
357     \textcolor{keywordflow}{for} (\hyperlink{class_k_k_b_1_1_k_k_queue_aeb057c9c010446f46f57c1e355f981f1}{const\_iterator} x = q.begin ();  x != q.end (); x++)
358       \hyperlink{class_k_k_b_1_1_k_k_queue_aa9fba4632b54268bf71ecb42dee0b575}{PushOnBack} (*x);
359     \textcolor{keywordflow}{return};
360   \}  \textcolor{comment}{/* AddQueue */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Back\+Of\+Queue@{Back\+Of\+Queue}}
\index{Back\+Of\+Queue@{Back\+Of\+Queue}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Back\+Of\+Queue() const }{BackOfQueue() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf K\+K\+Queue}$<$ Entry $>$\+::Entry\+Ptr K\+K\+Queue\+::\+Back\+Of\+Queue (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_k_k_b_1_1_k_k_queue_a9c3fadab17ce05dc750d96b6d3fad064}{}\label{class_k_k_b_1_1_k_k_queue_a9c3fadab17ce05dc750d96b6d3fad064}
Returns pointer of last element in the container without removing it. If the container is empty will return N\+U\+LL. 

Definition at line 661 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
662   \{
663     \textcolor{keywordflow}{if}  (KKQueue<Entry>::size () <= 0)
664       \textcolor{keywordflow}{return} NULL;
665     \textcolor{keywordflow}{return} KKQueue<Entry>::back ();
666   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Delete\+Contents@{Delete\+Contents}}
\index{Delete\+Contents@{Delete\+Contents}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Delete\+Contents()}{DeleteContents()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ void K\+K\+Queue\+::\+Delete\+Contents (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_k_k_queue_a72dbe1e65d567536dbf4be3617230254}{}\label{class_k_k_b_1_1_k_k_queue_a72dbe1e65d567536dbf4be3617230254}
Empties the container, if \textquotesingle{}owner\textquotesingle{} is set to true will call the destructor on each element. 

Definition at line 321 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
322   \{
323     \textcolor{keywordflow}{if}  (owner)
324     \{
325       \hyperlink{class_k_k_b_1_1_k_k_queue_aa3c2796a726eea468b94132a9fbf2cfe}{iterator}  idx;
326 
327       \textcolor{keywordflow}{for}  (idx = KKQueue<Entry>::begin ();  idx != KKQueue<Entry>::end ();  idx++)
328       \{
329         \textcolor{keyword}{delete}  (*idx);
330       \}
331     \}
332 
333     KKQueue<Entry>::clear ();
334   \}  \textcolor{comment}{/* DeleteContents */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Delete\+Entry@{Delete\+Entry}}
\index{Delete\+Entry@{Delete\+Entry}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Delete\+Entry(\+Entry\+Ptr \+\_\+entry)}{DeleteEntry(EntryPtr _entry)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ void K\+K\+Queue\+::\+Delete\+Entry (
\begin{DoxyParamCaption}
\item[{Entry\+Ptr}]{\+\_\+entry}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_k_k_queue_ae362e3b0a128e8a09182e167befda088}{}\label{class_k_k_b_1_1_k_k_queue_ae362e3b0a128e8a09182e167befda088}
Removes from \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} the entry who\textquotesingle{}s pointer = \textquotesingle{}\+\_\+entry\textquotesingle{} 

Definition at line 684 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
685   \{
686     \textcolor{keywordflow}{for}  (\hyperlink{class_k_k_b_1_1_k_k_queue_aa3c2796a726eea468b94132a9fbf2cfe}{iterator} y =  KKQueue<Entry>::begin (); y !=  KKQueue<Entry>::end ();  y++)
687     \{
688       \textcolor{keywordflow}{if}  (*y == \_entry)
689       \{
690         KKQueue<Entry>::erase (y);
691         \textcolor{keywordflow}{return};
692       \}
693     \}
694   \}  \textcolor{comment}{/* DeleteEntry */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Delete\+Entry@{Delete\+Entry}}
\index{Delete\+Entry@{Delete\+Entry}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Delete\+Entry(kkuint32 \+\_\+idx)}{DeleteEntry(kkuint32 _idx)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ void K\+K\+Queue\+::\+Delete\+Entry (
\begin{DoxyParamCaption}
\item[{{\bf kkuint32}}]{\+\_\+idx}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_k_k_queue_acc76c23f4e4e1ecddd5c82619a93d4b2}{}\label{class_k_k_b_1_1_k_k_queue_acc76c23f4e4e1ecddd5c82619a93d4b2}
Removes from \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} the entry who\textquotesingle{}s index = \textquotesingle{}\+\_\+idx\textquotesingle{}. 

Definition at line 715 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
716   \{
717     \textcolor{keywordflow}{if}  ((\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32})\_idx >=  KKQueue<Entry>::size ())
718       \textcolor{keywordflow}{return};
719 
720     \hyperlink{class_k_k_b_1_1_k_k_queue_aa3c2796a726eea468b94132a9fbf2cfe}{iterator}  i =  KKQueue<Entry>::begin ();
721 
722     \textcolor{keywordflow}{for} (\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} j = 0;  ((j < \_idx)  &&  (i !=  KKQueue<Entry>::end ()));  j++)
723       i++;
724 
725     EntryPtr  ep = *i;
726     KKQueue<Entry>::erase (i);
727   \}  \textcolor{comment}{/* DeleteEntry */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Duplicate\+List\+And\+Contents@{Duplicate\+List\+And\+Contents}}
\index{Duplicate\+List\+And\+Contents@{Duplicate\+List\+And\+Contents}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Duplicate\+List\+And\+Contents() const }{DuplicateListAndContents() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf K\+K\+Queue}$<$ Entry $>$ $\ast$ K\+K\+Queue\+::\+Duplicate\+List\+And\+Contents (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_k_k_b_1_1_k_k_queue_acc09d961e9f995ccf6183ff1a5e87e23}{}\label{class_k_k_b_1_1_k_k_queue_acc09d961e9f995ccf6183ff1a5e87e23}


Creates a new container including duplicating the contents, which also makes the new instance the owner of those contents. 



Definition at line 263 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
264   \{
265     KKQueue<Entry>*  duplicatedQueue = \textcolor{keyword}{new} KKQueue<Entry> (\textcolor{keyword}{true}, \hyperlink{class_k_k_b_1_1_k_k_queue_a1dab601f75ee6a65d97f02bddf71c40d}{QueueSize} ());
266 
267     \textcolor{keywordflow}{for}  (\hyperlink{class_k_k_b_1_1_k_k_queue_aeb057c9c010446f46f57c1e355f981f1}{const\_iterator} x = KKQueue<Entry>::begin ();  x != KKQueue<Entry>::end ();  x++)
268     \{
269       \textcolor{keyword}{const} EntryPtr e = *x;
270       duplicatedQueue->PushOnBack (\textcolor{keyword}{new} Entry (*e));
271     \}
272     
273     \textcolor{keywordflow}{return}  duplicatedQueue;
274   \}  \textcolor{comment}{/* DuplicateListAndContents */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Find\+The\+Kth\+Element@{Find\+The\+Kth\+Element}}
\index{Find\+The\+Kth\+Element@{Find\+The\+Kth\+Element}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Find\+The\+Kth\+Element(kkuint32 k, Functor pred)}{FindTheKthElement(kkuint32 k, Functor pred)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ template$<$typename Functor $>$ {\bf kkuint32} K\+K\+Queue\+::\+Find\+The\+Kth\+Element (
\begin{DoxyParamCaption}
\item[{{\bf kkuint32}}]{k, }
\item[{Functor}]{pred}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_k_k_queue_a0cc98856d9a20f8838bd647e0391e6b2}{}\label{class_k_k_b_1_1_k_k_queue_a0cc98856d9a20f8838bd647e0391e6b2}


Definition at line 527 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
530   \{
531     \textcolor{keywordflow}{if}  ((k < 0)   ||  (K > = (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})size ()))
532       \textcolor{keywordflow}{return} -1;
533     \textcolor{keywordflow}{return}  \hyperlink{class_k_k_b_1_1_k_k_queue_a0cc98856d9a20f8838bd647e0391e6b2}{FindTheKthElement} (k, 0, size () - 1, pred);
534   \}  \textcolor{comment}{/* FindTheKthElement */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Front\+Of\+Queue@{Front\+Of\+Queue}}
\index{Front\+Of\+Queue@{Front\+Of\+Queue}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Front\+Of\+Queue() const }{FrontOfQueue() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf K\+K\+Queue}$<$ Entry $>$\+::Entry\+Ptr K\+K\+Queue\+::\+Front\+Of\+Queue (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_k_k_b_1_1_k_k_queue_af449cfe0b0d33b6623949be7b7dc1103}{}\label{class_k_k_b_1_1_k_k_queue_af449cfe0b0d33b6623949be7b7dc1103}
Returns a pointer to the element that is at from of the queue with out removing it from the queue. 

Definition at line 673 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
674   \{
675     \textcolor{keywordflow}{if}  ( KKQueue<Entry>::size () <= 0)
676        \textcolor{keywordflow}{return} NULL;
677 
678     \textcolor{keywordflow}{return} * KKQueue<Entry>::begin ();
679   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Get\+First@{Get\+First}}
\index{Get\+First@{Get\+First}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Get\+First() const }{GetFirst() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf K\+K\+Queue}$<$ Entry $>$\+::Entry\+Ptr K\+K\+Queue\+::\+Get\+First (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_k_k_b_1_1_k_k_queue_ad194def66421c09375d6c9c900a4c6d6}{}\label{class_k_k_b_1_1_k_k_queue_ad194def66421c09375d6c9c900a4c6d6}
Same as Front\+Of\+Queue. 

Definition at line 366 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
367   \{
368     \textcolor{keywordflow}{return}  \hyperlink{class_k_k_b_1_1_k_k_queue_af449cfe0b0d33b6623949be7b7dc1103}{FrontOfQueue} ();
369   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Get\+Last@{Get\+Last}}
\index{Get\+Last@{Get\+Last}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Get\+Last() const }{GetLast() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf K\+K\+Queue}$<$ Entry $>$\+::Entry\+Ptr K\+K\+Queue\+::\+Get\+Last (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_k_k_b_1_1_k_k_queue_a8cd2a0f6218ce6f63cba5c0dacf97fdf}{}\label{class_k_k_b_1_1_k_k_queue_a8cd2a0f6218ce6f63cba5c0dacf97fdf}
Same as Back\+Of\+Queue. 

Definition at line 374 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
375   \{
376     \textcolor{keywordflow}{return}  \hyperlink{class_k_k_b_1_1_k_k_queue_a9c3fadab17ce05dc750d96b6d3fad064}{BackOfQueue} ();
377   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Idx\+To\+Ptr@{Idx\+To\+Ptr}}
\index{Idx\+To\+Ptr@{Idx\+To\+Ptr}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Idx\+To\+Ptr(kkuint32 idx) const }{IdxToPtr(kkuint32 idx) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf K\+K\+Queue}$<$ Entry $>$\+::Entry\+Ptr K\+K\+Queue\+::\+Idx\+To\+Ptr (
\begin{DoxyParamCaption}
\item[{{\bf kkuint32}}]{idx}
\end{DoxyParamCaption}
) const}\hypertarget{class_k_k_b_1_1_k_k_queue_acce2bdd8b3327e38266cf198382cd852}{}\label{class_k_k_b_1_1_k_k_queue_acce2bdd8b3327e38266cf198382cd852}
Returns back a pointer to the element who\textquotesingle{}s index is \textquotesingle{}idx\textquotesingle{}. If \textquotesingle{}idx\textquotesingle{} is less than 0 or $>$= \hyperlink{class_k_k_b_1_1_k_k_queue_a1dab601f75ee6a65d97f02bddf71c40d}{Queue\+Size()} will return N\+U\+LL. 

Definition at line 732 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
733   \{
734     \textcolor{keywordflow}{if}  (idx >= KKQueue<Entry>::size ())
735       \textcolor{keywordflow}{return} NULL;
736 
737     \textcolor{keywordflow}{return}  &((*this)[idx]);
738     \textcolor{comment}{//return  (typename Entry*)(vector<Entry*>::operator[] (idx));}
739   \}  \textcolor{comment}{/* IdxToPtr */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Locate\+Entry@{Locate\+Entry}}
\index{Locate\+Entry@{Locate\+Entry}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Locate\+Entry(\+Entry\+Const\+Ptr \+\_\+entry) const }{LocateEntry(EntryConstPtr _entry) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf kkint32} K\+K\+Queue\+::\+Locate\+Entry (
\begin{DoxyParamCaption}
\item[{Entry\+Const\+Ptr}]{\+\_\+entry}
\end{DoxyParamCaption}
) const}\hypertarget{class_k_k_b_1_1_k_k_queue_a7605c8e51c5b1c5182482dab8226e4bc}{}\label{class_k_k_b_1_1_k_k_queue_a7605c8e51c5b1c5182482dab8226e4bc}
Returns the index of the element who\textquotesingle{}s address is \textquotesingle{}\+\_\+entry\textquotesingle{}. If not found in container will return back -\/1. 

Definition at line 745 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
746   \{
747     \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  i = 0; 
748 
749     \textcolor{keywordflow}{for}  (\hyperlink{class_k_k_b_1_1_k_k_queue_aeb057c9c010446f46f57c1e355f981f1}{const\_iterator} j = KKQueue<Entry>::begin ();  j != KKQueue<Entry>::end (); j++)
750     \{
751       \textcolor{keywordflow}{if}  (*j == \_entry)
752         \textcolor{keywordflow}{return} i;
753       i++;
754     \}
755     \textcolor{keywordflow}{return} -1;
756   \}  \textcolor{comment}{/* LocateEntry */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Look\+At\+Back@{Look\+At\+Back}}
\index{Look\+At\+Back@{Look\+At\+Back}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Look\+At\+Back() const }{LookAtBack() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf K\+K\+Queue}$<$ Entry $>$\+::Entry\+Ptr K\+K\+Queue\+::\+Look\+At\+Back (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_k_k_b_1_1_k_k_queue_a7d818f2e1710a314f2bba035fe86dd41}{}\label{class_k_k_b_1_1_k_k_queue_a7d818f2e1710a314f2bba035fe86dd41}
Same as Back\+Of\+Queue. 

Definition at line 627 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
628   \{
629     \textcolor{keywordflow}{if}  (this->size () <= 0)
630       \textcolor{keywordflow}{return} NULL;
631 
632     \textcolor{keywordflow}{return}  KKQueue<Entry>::back ();
633   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Look\+At\+Front@{Look\+At\+Front}}
\index{Look\+At\+Front@{Look\+At\+Front}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Look\+At\+Front() const }{LookAtFront() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf K\+K\+Queue}$<$ Entry $>$\+::Entry\+Ptr K\+K\+Queue\+::\+Look\+At\+Front (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_k_k_b_1_1_k_k_queue_a33e29d962c414c890db00f8c25224a82}{}\label{class_k_k_b_1_1_k_k_queue_a33e29d962c414c890db00f8c25224a82}
Same as Front\+Of\+Queue. 

Definition at line 638 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
639   \{
640     \textcolor{keywordflow}{if}  (this->size () <= 0)
641       \textcolor{keywordflow}{return} NULL;
642     \textcolor{keywordflow}{return}  *KKQueue<Entry>::begin ();
643   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{operator"!=(const K\+K\+Queue$<$ Entry $>$ \&right\+Side) const }{operator!=(const KKQueue< Entry > &rightSide) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry$>$ bool K\+K\+Queue\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf K\+K\+Queue}$<$ Entry $>$ \&}]{right\+Side}
\end{DoxyParamCaption}
) const}\hypertarget{class_k_k_b_1_1_k_k_queue_a5960ccd8db282fcb7955852e755baa14}{}\label{class_k_k_b_1_1_k_k_queue_a5960ccd8db282fcb7955852e755baa14}


returns False if N\+OT every entry in both containers point to the same elements 



Definition at line 457 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
458   \{
459     \textcolor{keywordflow}{return}  !((*this) == rightSide);
460   \} \textcolor{comment}{/* operator!= */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!operator=@{operator=}}
\index{operator=@{operator=}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{operator=(const K\+K\+Queue \&q)}{operator=(const KKQueue &q)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf K\+K\+Queue}$<$ Entry $>$ \& K\+K\+Queue\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf K\+K\+Queue}$<$ Entry $>$ \&}]{q}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_k_k_queue_ac1e30c66658adfcd502af08d177af7da}{}\label{class_k_k_b_1_1_k_k_queue_ac1e30c66658adfcd502af08d177af7da}


Assignment Operator. 


\begin{DoxyCode}
1) Destroy\textcolor{stringliteral}{'s its current contents by calling '}\hyperlink{class_k_k_b_1_1_k_k_queue_a72dbe1e65d567536dbf4be3617230254}{DeleteContents}\textcolor{stringliteral}{'.}
\textcolor{stringliteral}{2) If '}q\textcolor{stringliteral}{' owns its contents }
\textcolor{stringliteral}{     create new instances of '}q\textcolor{stringliteral}{'s contents and add to its self  then set '}owner\textcolor{stringliteral}{' flag to true.}
\textcolor{stringliteral}{   else }
\textcolor{stringliteral}{     Copy over '}q\textcolor{stringliteral}{'s pointers to self and then set '}owner\textcolor{stringliteral}{' flag to false.}
\end{DoxyCode}
 

Definition at line 415 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
416   \{
417     \hyperlink{class_k_k_b_1_1_k_k_queue_a72dbe1e65d567536dbf4be3617230254}{DeleteContents} ();
418 
419     \textcolor{keywordflow}{if}  (q.Owner ())
420     \{
421       \textcolor{keywordflow}{for}  (\hyperlink{class_k_k_b_1_1_k_k_queue_aeb057c9c010446f46f57c1e355f981f1}{const\_iterator}  x = q.begin ();  x < q.end (); x++)
422         push\_back (\textcolor{keyword}{new} Entry (**x));
423       this->\hyperlink{class_k_k_b_1_1_k_k_queue_a4990d037ff09dd504cc7df53819bf61a}{Owner} (\textcolor{keyword}{true});
424     \}
425     \textcolor{keywordflow}{else}
426     \{
427       \textcolor{keywordflow}{for}  (\hyperlink{class_k_k_b_1_1_k_k_queue_aeb057c9c010446f46f57c1e355f981f1}{const\_iterator}  x = q.begin ();  x < q.end (); x++)
428         push\_back (*x);
429       this->\hyperlink{class_k_k_b_1_1_k_k_queue_a4990d037ff09dd504cc7df53819bf61a}{Owner} (\textcolor{keyword}{false});
430     \}
431     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
432   \}  \textcolor{comment}{/* operator= */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!operator==@{operator==}}
\index{operator==@{operator==}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{operator==(const K\+K\+Queue$<$ Entry $>$ \&right\+Side) const }{operator==(const KKQueue< Entry > &rightSide) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry$>$ bool K\+K\+Queue\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf K\+K\+Queue}$<$ Entry $>$ \&}]{right\+Side}
\end{DoxyParamCaption}
) const}\hypertarget{class_k_k_b_1_1_k_k_queue_a93ba7b2058bef5c355f003fe3bdbcab6}{}\label{class_k_k_b_1_1_k_k_queue_a93ba7b2058bef5c355f003fe3bdbcab6}


Returns True if every entry in both containers point to the same elements. 



Definition at line 438 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
439   \{
440     \textcolor{keywordflow}{if}  (\hyperlink{class_k_k_b_1_1_k_k_queue_a1dab601f75ee6a65d97f02bddf71c40d}{QueueSize} () != rightSide.QueueSize ())
441       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
442 
443     \textcolor{keywordflow}{for} (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32} x = 0;  x < \hyperlink{class_k_k_b_1_1_k_k_queue_a1dab601f75ee6a65d97f02bddf71c40d}{QueueSize} ();  x++)
444     \{
445       Entry*  left  = \hyperlink{class_k_k_b_1_1_k_k_queue_acce2bdd8b3327e38266cf198382cd852}{IdxToPtr} (x);
446       Entry*  right = rightSide.IdxToPtr (x);
447       \textcolor{keywordflow}{if}  (!((*left) == (*right)))
448         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
449     \}
450 
451     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
452   \} \textcolor{comment}{/* operator== */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!operator\mbox{[}$\,$\mbox{]}@{operator[]}}
\index{operator\mbox{[}$\,$\mbox{]}@{operator[]}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{operator[](kkuint32 i) const }{operator[](kkuint32 i) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ Entry \& K\+K\+Queue\+::operator\mbox{[}$\,$\mbox{]} (
\begin{DoxyParamCaption}
\item[{{\bf kkuint32}}]{i}
\end{DoxyParamCaption}
) const}\hypertarget{class_k_k_b_1_1_k_k_queue_a8c2edf92ac57e26fe47032ad4d92f165}{}\label{class_k_k_b_1_1_k_k_queue_a8c2edf92ac57e26fe47032ad4d92f165}
Returns a reference to element indexed by \textquotesingle{}i\textquotesingle{}; similar to Idx\+To\+Ptr except tat it returns a reference rather than a pointer.\+0 

Definition at line 802 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
803   \{
804     \textcolor{comment}{//KKQueue<Entry>::Entry*  entry;}
805 
806     \textcolor{keywordflow}{if}  ((idx < 0)  ||  (idx >= KKQueue<Entry>::size ()))
807     \{
808       std::cerr << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl} 
809                 << \textcolor{stringliteral}{"*** ERROR ***   KKQueue<Entry>::operator[], Index ["} << idx << \textcolor{stringliteral}{"] out of bounds."} << 
      \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl}
810                 << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
811       exit (-1);
812     \}
813 
814     \textcolor{keywordflow}{return}  (Entry&)*(std::vector<Entry*>::operator[] (idx));
815   \}  \textcolor{comment}{/* operator[] */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Owner@{Owner}}
\index{Owner@{Owner}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Owner() const }{Owner() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ bool K\+K\+Queue\+::\+Owner (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_k_k_b_1_1_k_k_queue_a4990d037ff09dd504cc7df53819bf61a}{}\label{class_k_k_b_1_1_k_k_queue_a4990d037ff09dd504cc7df53819bf61a}


Definition at line 305 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
306   \{
307     \textcolor{keywordflow}{return}  (owner != 0);
308   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Owner@{Owner}}
\index{Owner@{Owner}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Owner(bool \+\_\+owner)}{Owner(bool _owner)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ void K\+K\+Queue\+::\+Owner (
\begin{DoxyParamCaption}
\item[{bool}]{\+\_\+owner}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_k_k_queue_aaf47f5cb6057e35b9f0d230b8b9a3906}{}\label{class_k_k_b_1_1_k_k_queue_aaf47f5cb6057e35b9f0d230b8b9a3906}
You can specify who owns the contents of the container. \textquotesingle{}\+\_\+owner\textquotesingle{} == true means when the container is deleted it will also call the destructor for each element it contains. 

Definition at line 297 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
298   \{
299     owner = \_owner;
300   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Pop\+From\+Back@{Pop\+From\+Back}}
\index{Pop\+From\+Back@{Pop\+From\+Back}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Pop\+From\+Back()}{PopFromBack()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf K\+K\+Queue}$<$ Entry $>$\+::Entry\+Ptr K\+K\+Queue\+::\+Pop\+From\+Back (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{class_k_k_b_1_1_k_k_queue_a03844c19a838fed7e7bcc5816846dcfd}{}\label{class_k_k_b_1_1_k_k_queue_a03844c19a838fed7e7bcc5816846dcfd}
Removes the last element in the container and returns its pointer. If the container is empty will return N\+U\+LL. 

Reimplemented in \hyperlink{class_k_k_m_l_l_1_1_m_l_class_list_add4473f4d1f638b7c9e71506401657a4}{K\+K\+M\+L\+L\+::\+M\+L\+Class\+List}, \hyperlink{class_k_k_m_l_l_1_1_gray_scale_images_f_v_list_a3679526994558f36a28e2e4721733801}{K\+K\+M\+L\+L\+::\+Gray\+Scale\+Images\+F\+V\+List}, and \hyperlink{class_k_k_b_1_1_xml_attribute_list_ab4d9d743cb29b2954aea4a00a490bf3e}{K\+K\+B\+::\+Xml\+Attribute\+List}.



Definition at line 648 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
649   \{
650     \textcolor{keywordflow}{if}  (KKQueue<Entry>::size () <= 0)
651       \textcolor{keywordflow}{return} NULL;
652 
653     Entry*  e = KKQueue<Entry>::back ();
654     KKQueue<Entry>::pop\_back ();
655     \textcolor{keywordflow}{return} e;
656   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Pop\+From\+Front@{Pop\+From\+Front}}
\index{Pop\+From\+Front@{Pop\+From\+Front}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Pop\+From\+Front()}{PopFromFront()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf K\+K\+Queue}$<$ Entry $>$\+::Entry\+Ptr K\+K\+Queue\+::\+Pop\+From\+Front (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{class_k_k_b_1_1_k_k_queue_a2b2205f34516ac1f2950f441625d3ec7}{}\label{class_k_k_b_1_1_k_k_queue_a2b2205f34516ac1f2950f441625d3ec7}
Removes the first element in the container and returns its pointer. If the container is empty will return N\+U\+LL. 

Reimplemented in \hyperlink{class_k_k_m_l_l_1_1_m_l_class_list_aa551aed30ac1bcc60b2bdefabc5ea079}{K\+K\+M\+L\+L\+::\+M\+L\+Class\+List}.



Definition at line 596 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
597   \{
598     \textcolor{keywordflow}{if}  (KKQueue<Entry>::size () <= 0)
599     \{
600       \textcolor{keywordflow}{return} NULL;
601     \}
602 
603     \hyperlink{class_k_k_b_1_1_k_k_queue_aa3c2796a726eea468b94132a9fbf2cfe}{iterator} beg = KKQueue<Entry>::begin ();
604     Entry*  e = *beg;
605     KKQueue<Entry>::erase (beg);
606     \textcolor{keywordflow}{return}  e;
607   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Ptr\+To\+Idx@{Ptr\+To\+Idx}}
\index{Ptr\+To\+Idx@{Ptr\+To\+Idx}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Ptr\+To\+Idx(\+Entry\+Const\+Ptr \+\_\+entry) const }{PtrToIdx(EntryConstPtr _entry) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf kkint32} K\+K\+Queue\+::\+Ptr\+To\+Idx (
\begin{DoxyParamCaption}
\item[{Entry\+Const\+Ptr}]{\+\_\+entry}
\end{DoxyParamCaption}
) const}\hypertarget{class_k_k_b_1_1_k_k_queue_ac7c26abdf599669a4b0898534f735f99}{}\label{class_k_k_b_1_1_k_k_queue_ac7c26abdf599669a4b0898534f735f99}
returns the index of the \textquotesingle{}entry\textquotesingle{} that has the same pointer as \textquotesingle{}\+\_\+entry\textquotesingle{}, if none found returns -\/1 

Definition at line 761 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
762   \{
763     \textcolor{keywordflow}{return}  \hyperlink{class_k_k_b_1_1_k_k_queue_a7605c8e51c5b1c5182482dab8226e4bc}{LocateEntry} (\_entry);
764   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Push\+On\+Back@{Push\+On\+Back}}
\index{Push\+On\+Back@{Push\+On\+Back}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Push\+On\+Back(\+Entry\+Ptr \+\_\+entry)}{PushOnBack(EntryPtr _entry)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ void K\+K\+Queue\+::\+Push\+On\+Back (
\begin{DoxyParamCaption}
\item[{Entry\+Ptr}]{\+\_\+entry}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{class_k_k_b_1_1_k_k_queue_aa9fba4632b54268bf71ecb42dee0b575}{}\label{class_k_k_b_1_1_k_k_queue_aa9fba4632b54268bf71ecb42dee0b575}
Adds \textquotesingle{}\+\_\+entry\textquotesingle{} to the End of the container. 

Reimplemented in \hyperlink{class_k_k_b_1_1_xml_attribute_list_ad301a537bc8b1216d51f2cfc2a4383c0}{K\+K\+B\+::\+Xml\+Attribute\+List}.



Definition at line 398 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
399   \{
400     this->push\_back (\_entry);
401 
402     EntryPtr  e = KKQueue<Entry>::back ();
403 
404     \textcolor{keywordflow}{if}  (e != \_entry)
405     \{
406       std::cerr << \textcolor{stringliteral}{"KKQueue<Entry>::PushOnBack   ***ERROR***    Operation Failed!!!"} << 
      \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
407     \}
408     \textcolor{comment}{//vector<Entry*>  x;}
409   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Push\+On\+Front@{Push\+On\+Front}}
\index{Push\+On\+Front@{Push\+On\+Front}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Push\+On\+Front(\+Entry\+Ptr \+\_\+entry)}{PushOnFront(EntryPtr _entry)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ void K\+K\+Queue\+::\+Push\+On\+Front (
\begin{DoxyParamCaption}
\item[{Entry\+Ptr}]{\+\_\+entry}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{class_k_k_b_1_1_k_k_queue_a07b83a99241a167f7a395a40d32f6380}{}\label{class_k_k_b_1_1_k_k_queue_a07b83a99241a167f7a395a40d32f6380}
Adds \textquotesingle{}\+\_\+entry\textquotesingle{} to the Front of the container. 

Reimplemented in \hyperlink{class_k_k_b_1_1_xml_attribute_list_a8c659645b5e1e812e60cf847a4fd9c0b}{K\+K\+B\+::\+Xml\+Attribute\+List}.



Definition at line 383 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
384   \{
385     KKQueue<Entry>::insert (KKQueue<Entry>::begin (), \_entry);
386 
387     Entry*  e = *KKQueue<Entry>::begin ();
388 
389     \textcolor{keywordflow}{if}  (e != \_entry)
390     \{
391       std::cout << \textcolor{stringliteral}{"Error "} << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
392     \}
393 
394   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Queue\+Size@{Queue\+Size}}
\index{Queue\+Size@{Queue\+Size}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Queue\+Size() const }{QueueSize() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf kkint32} K\+K\+Queue\+::\+Queue\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_k_k_b_1_1_k_k_queue_a1dab601f75ee6a65d97f02bddf71c40d}{}\label{class_k_k_b_1_1_k_k_queue_a1dab601f75ee6a65d97f02bddf71c40d}
Same as calling vector$<$$>$\+::size(); returns the number of elements in \hyperlink{class_k_k_b_1_1_k_k_queue}{K\+K\+Queue} 

Definition at line 313 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
314   \{
315     \textcolor{keywordflow}{return}  (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})this->size ();
316   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Randomize\+Order@{Randomize\+Order}}
\index{Randomize\+Order@{Randomize\+Order}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Randomize\+Order()}{RandomizeOrder()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ void K\+K\+Queue\+::\+Randomize\+Order (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_k_k_queue_ab43920c3ec182b87d3affa1e1611e1b0}{}\label{class_k_k_b_1_1_k_k_queue_ab43920c3ec182b87d3affa1e1611e1b0}


Randomizes the order of the vector. 

Implements the \char`\"{}\+Fisher-\/\+Yates Uniform Random Sort\char`\"{}; this implementation was done by Sergiy Fefilatyev (2011-\/01-\/27) 

Definition at line 469 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
470   \{
471     \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  i, j;
472     \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32}  numEntries = KKQueue<Entry>::size ();
473     \textcolor{keywordflow}{if}  (numEntries < 2)
474       \textcolor{keywordflow}{return};
475 
476     i = numEntries - 1;
477     \textcolor{keywordflow}{while} (\textcolor{keyword}{true})  
478     \{
479       j = \hyperlink{namespace_k_k_b_aad6ec2b84e0888ea95b620ce79b60e40}{LRand48}() % (i + 1);
480       \hyperlink{class_k_k_b_1_1_k_k_queue_a7a848286a5d2ddd9b0d320557a458f66}{SwapIndexes}  (i, j );
481       \textcolor{keywordflow}{if}  (i < 1)
482         \textcolor{keywordflow}{break};
483       i--;
484     \}
485   \}  \textcolor{comment}{/* RandomizeOrder */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Randomize\+Order@{Randomize\+Order}}
\index{Randomize\+Order@{Randomize\+Order}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Randomize\+Order(kkint64 seed)}{RandomizeOrder(kkint64 seed)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ void K\+K\+Queue\+::\+Randomize\+Order (
\begin{DoxyParamCaption}
\item[{{\bf kkint64}}]{seed}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_k_k_queue_a72f950cfa2e3482aa8c527eb024a57ee}{}\label{class_k_k_b_1_1_k_k_queue_a72f950cfa2e3482aa8c527eb024a57ee}


Definition at line 490 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
491   \{
492     \hyperlink{namespace_k_k_b_ab78431731ee8aed1c90baf2248d85b67}{SRand48} (seed);
493     \hyperlink{class_k_k_b_1_1_k_k_queue_ab43920c3ec182b87d3affa1e1611e1b0}{RandomizeOrder} ();
494   \}  \textcolor{comment}{/* RandomizeOrder */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Randomize\+Order@{Randomize\+Order}}
\index{Randomize\+Order@{Randomize\+Order}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Randomize\+Order(\+Random\+Num\+Generator \&random\+Variable)}{RandomizeOrder(RandomNumGenerator &randomVariable)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ void K\+K\+Queue\+::\+Randomize\+Order (
\begin{DoxyParamCaption}
\item[{{\bf Random\+Num\+Generator} \&}]{random\+Variable}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_k_k_queue_af9fd71e0f10f8383153eecbbbfce0f30}{}\label{class_k_k_b_1_1_k_k_queue_af9fd71e0f10f8383153eecbbbfce0f30}


Randomizes the order of the vector. 

Implements the \char`\"{}\+Fisher-\/\+Yates Uniform Random Sort\char`\"{}; this implementation was done by Sergiy Fefilatyev (2011-\/01-\/27) 

Definition at line 504 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
505   \{
506     \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  i, j;
507     \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32}  numEntries = KKQueue<Entry>::size ();
508     \textcolor{keywordflow}{if}  (numEntries < 2)
509       \textcolor{keywordflow}{return};
510 
511     i = numEntries - 1;
512     \textcolor{keywordflow}{while} (\textcolor{keyword}{true})  
513     \{
514       j = randomVariable.Next () % (i + 1);
515       \hyperlink{class_k_k_b_1_1_k_k_queue_a7a848286a5d2ddd9b0d320557a458f66}{SwapIndexes}  (i, j );
516       \textcolor{keywordflow}{if}  (i < 1)
517         \textcolor{keywordflow}{break};
518       i--;
519     \}
520   \}  \textcolor{comment}{/* RandomizeOrder */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Remove\+First@{Remove\+First}}
\index{Remove\+First@{Remove\+First}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Remove\+First()}{RemoveFirst()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf K\+K\+Queue}$<$ Entry $>$\+::Entry\+Ptr K\+K\+Queue\+::\+Remove\+First (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{class_k_k_b_1_1_k_k_queue_a667988c7ff02753f1324fb6c52debf84}{}\label{class_k_k_b_1_1_k_k_queue_a667988c7ff02753f1324fb6c52debf84}
same as Pop\+From\+Front 

Definition at line 611 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
612   \{
613     \textcolor{keywordflow}{return}  \hyperlink{class_k_k_b_1_1_k_k_queue_a2b2205f34516ac1f2950f441625d3ec7}{PopFromFront} ();
614   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Remove\+Last@{Remove\+Last}}
\index{Remove\+Last@{Remove\+Last}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Remove\+Last()}{RemoveLast()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ {\bf K\+K\+Queue}$<$ Entry $>$\+::Entry\+Ptr K\+K\+Queue\+::\+Remove\+Last (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{class_k_k_b_1_1_k_k_queue_ae25cc5a483346ddf4231ae30d29f0b2e}{}\label{class_k_k_b_1_1_k_k_queue_ae25cc5a483346ddf4231ae30d29f0b2e}
same as Pop\+From\+Back 

Definition at line 619 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
620   \{
621     \textcolor{keywordflow}{return}  \hyperlink{class_k_k_b_1_1_k_k_queue_a03844c19a838fed7e7bcc5816846dcfd}{PopFromBack} ();
622   \}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Set\+Idx\+To\+Ptr@{Set\+Idx\+To\+Ptr}}
\index{Set\+Idx\+To\+Ptr@{Set\+Idx\+To\+Ptr}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Set\+Idx\+To\+Ptr(kkuint32 \+\_\+idx, Entry $\ast$\+\_\+ptr)}{SetIdxToPtr(kkuint32 _idx, Entry *_ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry$>$ void K\+K\+Queue\+::\+Set\+Idx\+To\+Ptr (
\begin{DoxyParamCaption}
\item[{{\bf kkuint32}}]{\+\_\+idx, }
\item[{Entry $\ast$}]{\+\_\+ptr}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_k_k_queue_a3f72bf16ba59d4269ecf5db9fad9ef9e}{}\label{class_k_k_b_1_1_k_k_queue_a3f72bf16ba59d4269ecf5db9fad9ef9e}


Definition at line 700 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
703   \{
704     \textcolor{keywordflow}{if}  ((\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32})\_idx >=  KKQueue<Entry>::size ())
705       \textcolor{keywordflow}{return};
706     
707     std::vector<Entry*>::operator[] (\_idx) = \_ptr;
708   \}  \textcolor{comment}{/* SetIdxToPtr */}
\end{DoxyCode}
\index{K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}!Swap\+Indexes@{Swap\+Indexes}}
\index{Swap\+Indexes@{Swap\+Indexes}!K\+K\+B\+::\+K\+K\+Queue@{K\+K\+B\+::\+K\+K\+Queue}}
\subsubsection[{\texorpdfstring{Swap\+Indexes(size\+\_\+t idx1, size\+\_\+t idx2)}{SwapIndexes(size_t idx1, size_t idx2)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Entry $>$ void K\+K\+Queue\+::\+Swap\+Indexes (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{idx1, }
\item[{size\+\_\+t}]{idx2}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_k_k_queue_a7a848286a5d2ddd9b0d320557a458f66}{}\label{class_k_k_b_1_1_k_k_queue_a7a848286a5d2ddd9b0d320557a458f66}


Definition at line 769 of file K\+K\+Queue.\+h.


\begin{DoxyCode}
770   \{
771     \textcolor{keywordflow}{if}  ((idx1 < 0)  ||  (idx1 >= KKQueue<Entry>::size ())  ||
772          (idx2 < 0)  ||  (idx2 >= KKQueue<Entry>::size ())
773         )
774     \{
775       std::cerr << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
776 
777       std::cerr << \textcolor{stringliteral}{"  ***  ERROR  ***  (KKQueue::SwapIndexes)  Indexes["} 
778                 << (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})idx1 << \textcolor{stringliteral}{", "} << (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})idx2 << "] Out of Range."
779                 << \hyperlink{namespacestd}{std}::\hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl};
780 
781       \hyperlink{namespacestd}{std}::cerr << "                   \hyperlink{class_k_k_b_1_1_k_k_queue_ac3a8d94136981f1db9ae5a9d591a0008}{KKQueue} Size[" << (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})
      \hyperlink{class_k_k_b_1_1_k_k_queue_ac3a8d94136981f1db9ae5a9d591a0008}{KKQueue}<Entry>::size () << "]." 
782                 << \hyperlink{namespacestd}{std}::endl
783                 << \hyperlink{namespacestd}{std}::endl;
784 
785       exit (1);
786     \}
787 
788     \textcolor{comment}{//vector<typename Entry*>&  us (*this);}
789     EntryPtr  tempPtr = \hyperlink{namespacestd}{std}::vector<Entry*>::operator[] (idx1);
790 
791     \textcolor{comment}{// (*this)[idx1];}
792 
793     \hyperlink{namespacestd}{std}::vector<EntryPtr>::operator[] (idx1) = \hyperlink{namespacestd}{std}::vector<EntryPtr>::operator[] (idx2);
794     \hyperlink{namespacestd}{std}::vector<EntryPtr>::operator[] (idx2) = tempPtr;
795     \textcolor{comment}{//(*this)[idx1] = (*this)[idx2];}
796     \textcolor{comment}{//(*this)[idx2] = tempPtr;}
797   \}  \textcolor{comment}{/* SwapIndexes */}
\end{DoxyCode}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/\+Kurt/\+Git\+Hub/\+K\+Square\+Libraries/\+K\+K\+Base/\hyperlink{_k_k_queue_8h}{K\+K\+Queue.\+h}\end{DoxyCompactItemize}
