\hypertarget{class_k_k_b_1_1_goal_keeper_simple}{}\section{K\+KB\+:\+:Goal\+Keeper\+Simple Class Reference}
\label{class_k_k_b_1_1_goal_keeper_simple}\index{K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}}


A simple/ light-\/weight implementation of critical section blocking.  




{\ttfamily \#include $<$Goal\+Keeper\+Simple.\+h$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} $\ast$ \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a5e73be577d62a04e6980bb94027f653b}{Goal\+Keeper\+Simple\+Ptr}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a51edc4dadfce50698b176d32de92bb6b}{Blocked} ()
\begin{DoxyCompactList}\small\item\em Will return true if any thread lock on this instance of \char`\"{}\+Goal\+Keeper\+Simple\char`\"{}. \end{DoxyCompactList}\item 
bool \hyperlink{class_k_k_b_1_1_goal_keeper_simple_ad6ccd73565c390cfca0a3b7f47be1c92}{Blocked\+By\+Another\+Thread} ()
\begin{DoxyCompactList}\small\item\em Returns true if a different thread has this instance of \char`\"{}\+Goal\+Keeper\+Simple\char`\"{} locked. \end{DoxyCompactList}\item 
\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32} \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a01d9c3b3552977dfbdd187112d89dc53}{Blocker\+Thread\+Id} ()
\begin{DoxyCompactList}\small\item\em Thread\+Id of thread that currently holds the Block -\/1 indicates no Block. \end{DoxyCompactList}\item 
void \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a28a529882f7ace4f8300508d4dee9c3e}{End\+Block} ()
\begin{DoxyCompactList}\small\item\em Ends the block and allows other threads to pass through Stat\+Block. \end{DoxyCompactList}\item 
\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32} \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a89e05c58c7d851dc6ad858803c37309a}{Memory\+Consumed\+Estimated} () const 
\item 
const \hyperlink{class_k_k_b_1_1_k_k_str}{K\+K\+Str} \& \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a13ef01792887b13a97315780f05fe319}{Name} () const 
\item 
void \hyperlink{class_k_k_b_1_1_goal_keeper_simple_aa8bcf9dcd7f07275aaac8ecdedac8cb1}{Start\+Block} ()
\begin{DoxyCompactList}\small\item\em Initiates a Block as long as another thread has not already locked this object. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a7001b3a689776a4ef2b56219f965b26c}{Create} (const \hyperlink{class_k_k_b_1_1_k_k_str}{K\+K\+Str} \&\+\_\+name, volatile \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a5e73be577d62a04e6980bb94027f653b}{Goal\+Keeper\+Simple\+Ptr} \&\+\_\+new\+Goal\+Keeper)
\begin{DoxyCompactList}\small\item\em Create a \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} object and avoid a race condition doing it. \end{DoxyCompactList}\item 
static void \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a3cdf495c3b29603a4434ad16a76bc049}{Create\+And\+Start\+Block} (const \hyperlink{class_k_k_b_1_1_k_k_str}{K\+K\+Str} \&\+\_\+name, volatile \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a5e73be577d62a04e6980bb94027f653b}{Goal\+Keeper\+Simple\+Ptr} \&\+\_\+new\+Goal\+Keeper, bool \&\+\_\+did\+Not\+Exist\+Yet)
\begin{DoxyCompactList}\small\item\em Create a \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} object and avoid a race condition doing it. \end{DoxyCompactList}\item 
static void \hyperlink{class_k_k_b_1_1_goal_keeper_simple_aa1098674662d5e6a03fb4af27e1c5af5}{Destroy} (volatile \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a5e73be577d62a04e6980bb94027f653b}{Goal\+Keeper\+Simple\+Ptr} \&\+\_\+goal\+Keeper\+Instance)
\begin{DoxyCompactList}\small\item\em Destroys an existing instance of \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple}. \end{DoxyCompactList}\item 
static void \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a8b38fb338438be5de8e2aaa2ac3b227d}{Final\+Clean\+Up} ()
\begin{DoxyCompactList}\small\item\em Will be registered with \textquotesingle{}atexit\textquotesingle{} so that it will be called when program is unloaded from memory. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a3c22ebe8b841379f92ef7cdfe3aed61c}{K\+K\+Queue$<$ Goal\+Keeper\+Simple $>$}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
A simple/ light-\/weight implementation of critical section blocking. 

Definition at line 29 of file Goal\+Keeper\+Simple.\+h.



\subsection{Member Typedef Documentation}
\index{K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}!Goal\+Keeper\+Simple\+Ptr@{Goal\+Keeper\+Simple\+Ptr}}
\index{Goal\+Keeper\+Simple\+Ptr@{Goal\+Keeper\+Simple\+Ptr}!K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}}
\subsubsection[{\texorpdfstring{Goal\+Keeper\+Simple\+Ptr}{GoalKeeperSimplePtr}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Goal\+Keeper\+Simple}$\ast$ {\bf K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+Goal\+Keeper\+Simple\+Ptr}}\hypertarget{class_k_k_b_1_1_goal_keeper_simple_a5e73be577d62a04e6980bb94027f653b}{}\label{class_k_k_b_1_1_goal_keeper_simple_a5e73be577d62a04e6980bb94027f653b}


Definition at line 32 of file Goal\+Keeper\+Simple.\+h.



\subsection{Member Function Documentation}
\index{K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}!Blocked@{Blocked}}
\index{Blocked@{Blocked}!K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}}
\subsubsection[{\texorpdfstring{Blocked()}{Blocked()}}]{\setlength{\rightskip}{0pt plus 5cm}bool Goal\+Keeper\+Simple\+::\+Blocked (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_goal_keeper_simple_a51edc4dadfce50698b176d32de92bb6b}{}\label{class_k_k_b_1_1_goal_keeper_simple_a51edc4dadfce50698b176d32de92bb6b}


Will return true if any thread lock on this instance of \char`\"{}\+Goal\+Keeper\+Simple\char`\"{}. 



Definition at line 76 of file Goal\+Keeper\+Simple.\+cpp.


\begin{DoxyCode}
77 \{
78   \textcolor{keywordflow}{return}  blocked;
79 \}  \textcolor{comment}{/* Blocked */}
\end{DoxyCode}
\index{K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}!Blocked\+By\+Another\+Thread@{Blocked\+By\+Another\+Thread}}
\index{Blocked\+By\+Another\+Thread@{Blocked\+By\+Another\+Thread}!K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}}
\subsubsection[{\texorpdfstring{Blocked\+By\+Another\+Thread()}{BlockedByAnotherThread()}}]{\setlength{\rightskip}{0pt plus 5cm}bool Goal\+Keeper\+Simple\+::\+Blocked\+By\+Another\+Thread (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_goal_keeper_simple_ad6ccd73565c390cfca0a3b7f47be1c92}{}\label{class_k_k_b_1_1_goal_keeper_simple_ad6ccd73565c390cfca0a3b7f47be1c92}


Returns true if a different thread has this instance of \char`\"{}\+Goal\+Keeper\+Simple\char`\"{} locked. 

\hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} keeps track of which thread has a lock on this instance of \textquotesingle{}\hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple}\textquotesingle{}. This way we know if the calling thread is not the one to have a lock on the thread. 

Definition at line 83 of file Goal\+Keeper\+Simple.\+cpp.



References K\+K\+B\+::os\+Get\+Thread\+Id().


\begin{DoxyCode}
84 \{
85   \textcolor{keywordflow}{if}  (!blocked)
86     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
87 
88   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  curThreadId = \hyperlink{namespace_k_k_b_aa1d581b15163a41037c43bdbd800d0f8}{KKB::osGetThreadId} ();
89   \textcolor{keywordflow}{return}  (blocked  &&  (curThreadId != blockerThreadId));
90 \}
\end{DoxyCode}
\index{K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}!Blocker\+Thread\+Id@{Blocker\+Thread\+Id}}
\index{Blocker\+Thread\+Id@{Blocker\+Thread\+Id}!K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}}
\subsubsection[{\texorpdfstring{Blocker\+Thread\+Id()}{BlockerThreadId()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf kkint32} Goal\+Keeper\+Simple\+::\+Blocker\+Thread\+Id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_goal_keeper_simple_a01d9c3b3552977dfbdd187112d89dc53}{}\label{class_k_k_b_1_1_goal_keeper_simple_a01d9c3b3552977dfbdd187112d89dc53}


Thread\+Id of thread that currently holds the Block -\/1 indicates no Block. 



Definition at line 404 of file Goal\+Keeper\+Simple.\+cpp.


\begin{DoxyCode}
405 \{
406   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  x = 0;
407   x =  blockerThreadId;
408   \textcolor{keywordflow}{return}  x;
409 \}
\end{DoxyCode}
\index{K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}!Create@{Create}}
\index{Create@{Create}!K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}}
\subsubsection[{\texorpdfstring{Create(const K\+K\+Str \&\+\_\+name, volatile Goal\+Keeper\+Simple\+Ptr \&\+\_\+new\+Goal\+Keeper)}{Create(const KKStr &_name, volatile GoalKeeperSimplePtr &_newGoalKeeper)}}]{\setlength{\rightskip}{0pt plus 5cm}void Goal\+Keeper\+Simple\+::\+Create (
\begin{DoxyParamCaption}
\item[{const {\bf K\+K\+Str} \&}]{\+\_\+name, }
\item[{volatile {\bf Goal\+Keeper\+Simple\+Ptr} \&}]{\+\_\+new\+Goal\+Keeper}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_k_k_b_1_1_goal_keeper_simple_a7001b3a689776a4ef2b56219f965b26c}{}\label{class_k_k_b_1_1_goal_keeper_simple_a7001b3a689776a4ef2b56219f965b26c}


Create a \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} object and avoid a race condition doing it. 

In case two different threads try to create the same \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} at the same time you only want one of them to succeed and the other to use same Gaol\+Keeper object. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em \+\_\+name} & Name of Goal Keeper object that you want to create. \\
\hline
\mbox{\tt in,out}  & {\em \+\_\+new\+Goal\+Keeper} & You pass this in. Create will block out the critical region that creates the \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} object. If it was already created, that is != N\+U\+LL will just return not changing its value. If it is still N\+U\+LL in the critical section it will create a new instance and set this parameter to its address. \\
\hline
\end{DoxyParams}
$<$ default security attributes

$<$ initially not owned 

Definition at line 160 of file Goal\+Keeper\+Simple.\+cpp.



References K\+K\+B\+::\+Goal\+Keeper\+Simple\+List\+::\+Goal\+Keeper\+Simple\+List().



Referenced by K\+K\+B\+::\+Msg\+Queue\+::\+Msg\+Queue().


\begin{DoxyCode}
163 \{
164 \textcolor{preprocessor}{#if  defined(WIN32)}
165   HANDLE  mutexCreateHandle = CreateMutex (NULL,                 \textcolor{comment}{/**< default security attributes */}
166                                            \textcolor{keyword}{false},                \textcolor{comment}{/**< initially not owned */}
167                                            \textcolor{stringliteral}{"GoalKeeperClass"}
168                                           );
169   \textcolor{keywordflow}{if}  (!mutexCreateHandle)
170   \{
171     \hyperlink{class_k_k_b_1_1_k_k_str}{KKStr} errMsg = \textcolor{stringliteral}{"GoalKeeperSimple::Create   ***ERROR***   CreateMutex failed; returned back NULL; 
       \_name:"} + \_name;
172     cerr << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl} << errMsg << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl} << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl};
173     \textcolor{keywordflow}{throw} \hyperlink{class_k_k_b_1_1_k_k_exception}{KKException} (errMsg);
174   \}
175 
176   WaitForSingleObject (mutexCreateHandle, INFINITE);
177 
178   \textcolor{keywordflow}{if}  (\_newGoalKeeper == NULL)
179   \{
180     \_newGoalKeeper = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{GoalKeeperSimple} (\_name);
181     \textcolor{keywordflow}{if}  (existingGoalKeepers == NULL)
182     \{
183       existingGoalKeepers = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_goal_keeper_simple_list}{GoalKeeperSimpleList} (\textcolor{keyword}{true});
184       atexit (\hyperlink{class_k_k_b_1_1_goal_keeper_simple_a8b38fb338438be5de8e2aaa2ac3b227d}{GoalKeeperSimple::FinalCleanUp});
185     \}
186     existingGoalKeepers->\hyperlink{class_k_k_b_1_1_k_k_queue_aa9fba4632b54268bf71ecb42dee0b575}{PushOnBack} (\_newGoalKeeper);
187   \}
188 
189   ReleaseMutex (mutexCreateHandle);
190   CloseHandle(mutexCreateHandle);
191 \textcolor{preprocessor}{#else}
192   sem\_t*  semHandle = sem\_open (\textcolor{stringliteral}{"GoalKeeperClass"}, O\_CREAT, 0644, 1);
193   \textcolor{keywordflow}{if}  (semHandle == SEM\_FAILED)
194   \{
195     cout << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl}
196          << \textcolor{stringliteral}{"GoalKeeperSimple::Create  Error["} << errno << \textcolor{stringliteral}{"] opening '/GoalKeeperSimple' Semaphore."} << 
      \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl}
197          << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
198 
199     perror(\textcolor{stringliteral}{"GoalKeeperSimple::Create   Error Opening Semaphore  'GoalKeeperSimple'"});
200 
201     \textcolor{keywordflow}{throw} \textcolor{stringliteral}{"GoalKeeperSimple::Create    Error opening 'GoalKeeperSimple'."};
202   \}
203 
204   sem\_wait (semHandle);
205 
206   \textcolor{keywordflow}{if}  (\_newGoalKeeper == NULL)
207   \{
208     \_newGoalKeeper = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{GoalKeeperSimple} (\_name);
209     \textcolor{keywordflow}{if}  (existingGoalKeepers == NULL)
210     \{
211       existingGoalKeepers = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_goal_keeper_simple_list}{GoalKeeperSimpleList} (\textcolor{keyword}{true});
212       atexit (\hyperlink{class_k_k_b_1_1_goal_keeper_simple_a8b38fb338438be5de8e2aaa2ac3b227d}{GoalKeeperSimple::FinalCleanUp});
213     \}
214     existingGoalKeepers->\hyperlink{class_k_k_b_1_1_k_k_queue_aa9fba4632b54268bf71ecb42dee0b575}{PushOnBack} (\_newGoalKeeper);
215   \}
216 
217   sem\_post (semHandle);
218   sem\_close (semHandle);
219 \textcolor{preprocessor}{#endif}
220 \}  \textcolor{comment}{/* Create */}
\end{DoxyCode}
\index{K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}!Create\+And\+Start\+Block@{Create\+And\+Start\+Block}}
\index{Create\+And\+Start\+Block@{Create\+And\+Start\+Block}!K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}}
\subsubsection[{\texorpdfstring{Create\+And\+Start\+Block(const K\+K\+Str \&\+\_\+name, volatile Goal\+Keeper\+Simple\+Ptr \&\+\_\+new\+Goal\+Keeper, bool \&\+\_\+did\+Not\+Exist\+Yet)}{CreateAndStartBlock(const KKStr &_name, volatile GoalKeeperSimplePtr &_newGoalKeeper, bool &_didNotExistYet)}}]{\setlength{\rightskip}{0pt plus 5cm}void Goal\+Keeper\+Simple\+::\+Create\+And\+Start\+Block (
\begin{DoxyParamCaption}
\item[{const {\bf K\+K\+Str} \&}]{\+\_\+name, }
\item[{volatile {\bf Goal\+Keeper\+Simple\+Ptr} \&}]{\+\_\+new\+Goal\+Keeper, }
\item[{bool \&}]{\+\_\+did\+Not\+Exist\+Yet}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_k_k_b_1_1_goal_keeper_simple_a3cdf495c3b29603a4434ad16a76bc049}{}\label{class_k_k_b_1_1_goal_keeper_simple_a3cdf495c3b29603a4434ad16a76bc049}


Create a \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} object and avoid a race condition doing it. 

Create a new instance of a \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} object if it has not already been done and locks it if we create it.

Similar to \textquotesingle{}Create\textquotesingle{} except it will also call the Start\+Block method. There is also an additional parameter that will let you know if your call was responsible for creating it.

In case two different threads try to create the same \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} at the same time you only want one of them to succeed and the other to use same Gaol\+Keeper object. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em \+\_\+name} & Name of Goal Keeper object that you want to create.\\
\hline
\mbox{\tt in,out}  & {\em \+\_\+new\+Goal\+Keeper} & You pass this in. Create will block out the critical region that creates the \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} object. If it was already created, that is != N\+U\+LL will just return not changing its value. If it is still N\+U\+LL in the critical section it will create a new instance and set this parameter to its address.\\
\hline
\mbox{\tt out}  & {\em \+\_\+did\+Not\+Exist\+Yet} & Indicates if this call had to create the \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} instance; if it already existed will return as false.\\
\hline
\mbox{\tt in}  & {\em \+\_\+name} & Name to be assigned to \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} object. \\
\hline
\mbox{\tt in,out}  & {\em \+\_\+new\+Goal\+Keeper} & A pointer to the \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} that already exists or to new one that got created. \\
\hline
\mbox{\tt out}  & {\em \+\_\+did\+Not\+Exist\+Yet} & Indicates if the call to \textquotesingle{}Create\+And\+Start\+Block\textquotesingle{} had to create a new instance. \\
\hline
\end{DoxyParams}
$<$ default security attributes.

$<$ initially not owned. 

Definition at line 231 of file Goal\+Keeper\+Simple.\+cpp.



References K\+K\+B\+::\+Goal\+Keeper\+Simple\+List\+::\+Goal\+Keeper\+Simple\+List(), and Start\+Block().


\begin{DoxyCode}
235 \{
236 \textcolor{preprocessor}{#if  defined(WIN32)}
237   HANDLE  mutexCreateHandle = CreateMutex (NULL,                 \textcolor{comment}{/**< default security attributes. */}
238                                            \textcolor{keyword}{false},                \textcolor{comment}{/**< initially not owned.         */}
239                                            \textcolor{stringliteral}{"GoalKeeperClass"}
240                                           ); 
241   \textcolor{keywordflow}{if}  (!mutexCreateHandle)
242   \{
243     \hyperlink{class_k_k_b_1_1_k_k_str}{KKStr} errMsg = \textcolor{stringliteral}{"GoalKeeperSimple::CreateAndStartBlock   ***ERROR***   CreateMutex failed; returned
       back NULL;  \_name:"} + \_name;
244     cerr << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl} << errMsg << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl} << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl};
245     \textcolor{keywordflow}{throw} \hyperlink{class_k_k_b_1_1_k_k_exception}{KKException}(errMsg);
246   \}
247 
248   WaitForSingleObject (mutexCreateHandle, INFINITE);
249 
250   \textcolor{keywordflow}{if}  (\_newGoalKeeper == NULL)
251   \{
252     \_didNotExistYet = \textcolor{keyword}{true};
253     \_newGoalKeeper = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{GoalKeeperSimple} (\_name);
254 
255     \textcolor{keywordflow}{if}  (existingGoalKeepers == NULL)
256     \{
257       existingGoalKeepers = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_goal_keeper_simple_list}{GoalKeeperSimpleList} (\textcolor{keyword}{true});
258       atexit (\hyperlink{class_k_k_b_1_1_goal_keeper_simple_a8b38fb338438be5de8e2aaa2ac3b227d}{GoalKeeperSimple::FinalCleanUp});
259     \}
260     existingGoalKeepers->\hyperlink{class_k_k_b_1_1_k_k_queue_aa9fba4632b54268bf71ecb42dee0b575}{PushOnBack} (\_newGoalKeeper);
261   \}
262   \textcolor{keywordflow}{else}
263   \{
264     \_didNotExistYet = \textcolor{keyword}{false};
265   \}
266 
267   \_newGoalKeeper->StartBlock ();
268 
269   ReleaseMutex (mutexCreateHandle);
270   CloseHandle(mutexCreateHandle);
271 \textcolor{preprocessor}{#else}
272   sem\_t*  semHandle = sem\_open (\textcolor{stringliteral}{"GoalKeeperClass"}, O\_CREAT, 0644, 1);
273   \textcolor{keywordflow}{if}  (semHandle == SEM\_FAILED)
274   \{
275     cout << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl}
276          << \textcolor{stringliteral}{"GoalKeeperSimple::Create  Error["} << errno << \textcolor{stringliteral}{"] opening '/GoalKeeperSimple' Semaphore."} << 
      \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl}
277          << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
278 
279     perror(\textcolor{stringliteral}{"GoalKeeperSimple::Create   Error Opening Semaphore  'GoalKeeperSimple'"});
280 
281     \textcolor{keywordflow}{throw} \textcolor{stringliteral}{"GoalKeeperSimple::Create    Error opening 'GoalKeeperSimple'."};
282   \}
283 
284   sem\_wait (semHandle);
285 
286   \textcolor{keywordflow}{if}  (\_newGoalKeeper == NULL)
287   \{
288     \_didNotExistYet = \textcolor{keyword}{true};
289     \_newGoalKeeper = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{GoalKeeperSimple} (\_name);
290     \textcolor{keywordflow}{if}  (existingGoalKeepers == NULL)
291     \{
292       existingGoalKeepers = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_goal_keeper_simple_list}{GoalKeeperSimpleList} (\textcolor{keyword}{true});
293       atexit (\hyperlink{class_k_k_b_1_1_goal_keeper_simple_a8b38fb338438be5de8e2aaa2ac3b227d}{GoalKeeperSimple::FinalCleanUp});
294     \}
295     existingGoalKeepers->\hyperlink{class_k_k_b_1_1_k_k_queue_aa9fba4632b54268bf71ecb42dee0b575}{PushOnBack} (\_newGoalKeeper);
296   \}
297   \textcolor{keywordflow}{else}
298   \{
299     \_didNotExistYet = \textcolor{keyword}{false};
300   \}
301 
302   \_newGoalKeeper->StartBlock ();
303 
304   sem\_post (semHandle);
305   sem\_close (semHandle);
306 \textcolor{preprocessor}{#endif}
307 \}  \textcolor{comment}{/* CreateAndStartBlock */}
\end{DoxyCode}
\index{K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}!Destroy@{Destroy}}
\index{Destroy@{Destroy}!K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}}
\subsubsection[{\texorpdfstring{Destroy(volatile Goal\+Keeper\+Simple\+Ptr \&\+\_\+goal\+Keeper\+Instance)}{Destroy(volatile GoalKeeperSimplePtr &_goalKeeperInstance)}}]{\setlength{\rightskip}{0pt plus 5cm}void Goal\+Keeper\+Simple\+::\+Destroy (
\begin{DoxyParamCaption}
\item[{volatile {\bf Goal\+Keeper\+Simple\+Ptr} \&}]{\+\_\+goal\+Keeper\+Instance}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_k_k_b_1_1_goal_keeper_simple_aa1098674662d5e6a03fb4af27e1c5af5}{}\label{class_k_k_b_1_1_goal_keeper_simple_aa1098674662d5e6a03fb4af27e1c5af5}


Destroys an existing instance of \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple}. 

Use this method rather than calling the destructor directly. This way the \textquotesingle{}existing\+Goal\+Keepers\textquotesingle{} data member can be kept up to date. If for some reason two different threads managed to call this method for the same \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} instance only one of them will actually destroy the instance. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em \+\_\+goal\+Keeper\+Instance} & Instance of \hyperlink{class_k_k_b_1_1_goal_keeper_simple}{Goal\+Keeper\+Simple} that is to be destroyed. Upon return it will be set to N\+U\+LL. \\
\hline
\end{DoxyParams}
$<$ default security attributes

$<$ initially not owned 

Definition at line 313 of file Goal\+Keeper\+Simple.\+cpp.



Referenced by K\+K\+B\+::\+Msg\+Queue\+::$\sim$\+Msg\+Queue().


\begin{DoxyCode}
314 \{
315 \textcolor{preprocessor}{#if  defined(WIN32)}
316   HANDLE  mutexCreateHandle = CreateMutex (NULL,                 \textcolor{comment}{/**< default security attributes */}
317                                            \textcolor{keyword}{false},                \textcolor{comment}{/**< initially not owned */}
318                                            \textcolor{stringliteral}{"GoalKeeperClass"}
319                                           ); 
320   \textcolor{keywordflow}{if} (!mutexCreateHandle)
321   \{
322     \hyperlink{class_k_k_b_1_1_k_k_str}{KKStr} errMsg = \textcolor{stringliteral}{"GoalKeeperSimple::Destroy   ***ERROR***   CreateMutex failed; returned back NULL"};
323     cerr << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl} << errMsg << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl} << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl};
324     \textcolor{keywordflow}{throw} \hyperlink{class_k_k_b_1_1_k_k_exception}{KKException}(errMsg);
325   \}
326 
327   WaitForSingleObject (mutexCreateHandle, INFINITE);
328 
329   \textcolor{keywordflow}{if}  (\_goalKeeperInstance == NULL)
330   \{
331     \textcolor{comment}{// Some other thread managed to destroy this instance.}
332   \}
333   \textcolor{keywordflow}{else}
334   \{
335     \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  existingInstanceIdx =  existingGoalKeepers->\hyperlink{class_k_k_b_1_1_k_k_queue_ac7c26abdf599669a4b0898534f735f99}{PtrToIdx} (\_goalKeeperInstance);
336     \textcolor{keywordflow}{if}  (existingInstanceIdx < 0)
337     \{
338       \textcolor{comment}{// If not in list then a  different thread beat us to destroying this instance or it was never
       created to start with.}
339     \}
340     \textcolor{keywordflow}{else}
341     \{
342       existingGoalKeepers->\hyperlink{class_k_k_b_1_1_k_k_queue_ae362e3b0a128e8a09182e167befda088}{DeleteEntry} (\_goalKeeperInstance);
343       \textcolor{keyword}{delete}  \_goalKeeperInstance;
344       \_goalKeeperInstance = NULL;
345     \}
346   \}
347 
348   ReleaseMutex (mutexCreateHandle);
349   CloseHandle(mutexCreateHandle);
350 \textcolor{preprocessor}{#else}
351   sem\_t*  semHandle = sem\_open (\textcolor{stringliteral}{"GoalKeeperClass"}, O\_CREAT, 0644, 1);
352   \textcolor{keywordflow}{if}  (semHandle == SEM\_FAILED)
353   \{
354     cout << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl}
355          << \textcolor{stringliteral}{"GoalKeeperSimple::Create  Error["} << errno << \textcolor{stringliteral}{"] opening '/GoalKeeperSimple' Semaphore."} << 
      \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl}
356          << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
357 
358     perror(\textcolor{stringliteral}{"GoalKeeperSimple::Create   Error Opening Semaphore  'GoalKeeperSimple'"});
359 
360     \textcolor{keywordflow}{throw} \textcolor{stringliteral}{"GoalKeeperSimple::Create    Error opening 'GoalKeeperSimple'."};
361   \}
362 
363   sem\_wait (semHandle);
364 
365   \textcolor{keywordflow}{if}  (\_goalKeeperInstance == NULL)
366   \{
367     \textcolor{comment}{// Some other thread managed to destroy this instance.}
368   \}
369   \textcolor{keywordflow}{else}
370   \{
371     \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  existingInstanceIdx =  existingGoalKeepers->\hyperlink{class_k_k_b_1_1_k_k_queue_ac7c26abdf599669a4b0898534f735f99}{PtrToIdx} (\_goalKeeperInstance);
372     \textcolor{keywordflow}{if}  (existingInstanceIdx >= 0)
373     \{
374       \textcolor{comment}{// If not in list then a  different thread beat us to destroying this instance or it was never
       created to start with.}
375     \}
376     \textcolor{keywordflow}{else}
377     \{
378       existingGoalKeepers->\hyperlink{class_k_k_b_1_1_k_k_queue_ae362e3b0a128e8a09182e167befda088}{DeleteEntry} (\_goalKeeperInstance);
379       \textcolor{keyword}{delete}  \_goalKeeperInstance;
380       \_goalKeeperInstance = NULL;
381     \}
382   \}
383 
384   sem\_post (semHandle);
385   sem\_close (semHandle);
386 \textcolor{preprocessor}{#endif}
387 
388 \}  \textcolor{comment}{/* Destroy */}
\end{DoxyCode}
\index{K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}!End\+Block@{End\+Block}}
\index{End\+Block@{End\+Block}!K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}}
\subsubsection[{\texorpdfstring{End\+Block()}{EndBlock()}}]{\setlength{\rightskip}{0pt plus 5cm}void Goal\+Keeper\+Simple\+::\+End\+Block (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_goal_keeper_simple_a28a529882f7ace4f8300508d4dee9c3e}{}\label{class_k_k_b_1_1_goal_keeper_simple_a28a529882f7ace4f8300508d4dee9c3e}


Ends the block and allows other threads to pass through Stat\+Block. 

Decrements the variable \textquotesingle{}blocker\+Depth\textquotesingle{} by one. Once \textquotesingle{}blocker\+Depth\textquotesingle{} is equal zero the Block on this instance is removed. The idea is that for each time in a row a Thread calls Start\+Block it has to call End\+Block the same number of times. 

Definition at line 139 of file Goal\+Keeper\+Simple.\+cpp.



References K\+K\+B\+::\+K\+K\+Exception\+::\+K\+K\+Exception(), K\+K\+B\+::\+K\+K\+Str\+::operator+(), K\+K\+B\+::operator+(), and K\+K\+B\+::os\+Get\+Thread\+Id().



Referenced by K\+K\+B\+::\+Msg\+Queue\+::\+Add\+Msg(), K\+K\+B\+::\+Msg\+Queue\+::\+Add\+Msgs(), K\+K\+B\+::\+Msg\+Queue\+::\+Get\+All\+Msgs(), K\+K\+B\+::\+Msg\+Queue\+::\+Get\+Copy\+Of\+Last\+Msg(), K\+K\+B\+::\+Msg\+Queue\+::\+Get\+Next\+Msg(), and K\+K\+B\+::\+Msg\+Queue\+::\+Memory\+Consumed\+Estimated().


\begin{DoxyCode}
140 \{
141   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  curThreadId = \hyperlink{namespace_k_k_b_aa1d581b15163a41037c43bdbd800d0f8}{KKB::osGetThreadId} ();
142   \textcolor{keywordflow}{if}  (!blocked)
143     \textcolor{keywordflow}{throw} \hyperlink{class_k_k_b_1_1_k_k_exception}{KKB::KKException} (\textcolor{stringliteral}{"GoalKeeperSimple::EndBlock    Name["} + name + \textcolor{stringliteral}{"]  Is not
       currently blocked."});
144 
145   \textcolor{keywordflow}{if}  (curThreadId != blockerThreadId)
146     \textcolor{keywordflow}{throw} \hyperlink{class_k_k_b_1_1_k_k_exception}{KKB::KKException} (\textcolor{stringliteral}{"GoalKeeperSimple::EndBlock    Name["} + name + \textcolor{stringliteral}{"]  ThreadId["} +
       blockerThreadId + \textcolor{stringliteral}{"] Currently holds Block;  our ThreadId["} + curThreadId + \textcolor{stringliteral}{"]"});
147 
148   --levels;
149   \textcolor{keywordflow}{if}  (levels < 1)
150   \{
151     blocked = \textcolor{keyword}{false};
152     blockerThreadId = -1;
153     CriticalSectionEnd ();
154   \}
155 \}  \textcolor{comment}{/* EndBlock */}
\end{DoxyCode}
\index{K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}!Final\+Clean\+Up@{Final\+Clean\+Up}}
\index{Final\+Clean\+Up@{Final\+Clean\+Up}!K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}}
\subsubsection[{\texorpdfstring{Final\+Clean\+Up()}{FinalCleanUp()}}]{\setlength{\rightskip}{0pt plus 5cm}void Goal\+Keeper\+Simple\+::\+Final\+Clean\+Up (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_k_k_b_1_1_goal_keeper_simple_a8b38fb338438be5de8e2aaa2ac3b227d}{}\label{class_k_k_b_1_1_goal_keeper_simple_a8b38fb338438be5de8e2aaa2ac3b227d}


Will be registered with \textquotesingle{}atexit\textquotesingle{} so that it will be called when program is unloaded from memory. 



Definition at line 392 of file Goal\+Keeper\+Simple.\+cpp.


\begin{DoxyCode}
393 \{
394   \textcolor{keywordflow}{if}  (existingGoalKeepers)
395   \{
396     \textcolor{keyword}{delete}  existingGoalKeepers;
397     existingGoalKeepers = NULL;
398   \}
399 \}
\end{DoxyCode}
\index{K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}!Memory\+Consumed\+Estimated@{Memory\+Consumed\+Estimated}}
\index{Memory\+Consumed\+Estimated@{Memory\+Consumed\+Estimated}!K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}}
\subsubsection[{\texorpdfstring{Memory\+Consumed\+Estimated() const }{MemoryConsumedEstimated() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf kkint32} Goal\+Keeper\+Simple\+::\+Memory\+Consumed\+Estimated (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_k_k_b_1_1_goal_keeper_simple_a89e05c58c7d851dc6ad858803c37309a}{}\label{class_k_k_b_1_1_goal_keeper_simple_a89e05c58c7d851dc6ad858803c37309a}


Definition at line 69 of file Goal\+Keeper\+Simple.\+cpp.



References K\+K\+B\+::\+K\+K\+Str\+::\+Memory\+Consumed\+Estimated().



Referenced by K\+K\+B\+::\+Msg\+Queue\+::\+Msg\+Queue().


\begin{DoxyCode}
70 \{
71   \textcolor{keywordflow}{return}  (\textcolor{keyword}{sizeof} (\hyperlink{class_k_k_b_1_1_goal_keeper_simple}{GoalKeeperSimple}) + name.
      \hyperlink{class_k_k_b_1_1_k_k_str_afc335bf98a8d4a77dc34215e72068719}{MemoryConsumedEstimated} ());
72 \}
\end{DoxyCode}
\index{K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}!Name@{Name}}
\index{Name@{Name}!K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}}
\subsubsection[{\texorpdfstring{Name() const }{Name() const }}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf K\+K\+Str}\& K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+Name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_k_k_b_1_1_goal_keeper_simple_a13ef01792887b13a97315780f05fe319}{}\label{class_k_k_b_1_1_goal_keeper_simple_a13ef01792887b13a97315780f05fe319}


Definition at line 122 of file Goal\+Keeper\+Simple.\+h.


\begin{DoxyCode}
122 \{\textcolor{keywordflow}{return}  name;\}
\end{DoxyCode}
\index{K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}!Start\+Block@{Start\+Block}}
\index{Start\+Block@{Start\+Block}!K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}}
\subsubsection[{\texorpdfstring{Start\+Block()}{StartBlock()}}]{\setlength{\rightskip}{0pt plus 5cm}void Goal\+Keeper\+Simple\+::\+Start\+Block (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_goal_keeper_simple_aa8bcf9dcd7f07275aaac8ecdedac8cb1}{}\label{class_k_k_b_1_1_goal_keeper_simple_aa8bcf9dcd7f07275aaac8ecdedac8cb1}


Initiates a Block as long as another thread has not already locked this object. 

If it is already blocked processor will sleep and then try again. As long as the variable \textquotesingle{}blocker\+Depth\textquotesingle{}is greater than zero this instance will be considered blocked. Once a thread has the instance blocked it will increment \textquotesingle{}blocker\+Depth\textquotesingle{} and return to caller. 

Definition at line 117 of file Goal\+Keeper\+Simple.\+cpp.



References K\+K\+B\+::os\+Get\+Thread\+Id().



Referenced by K\+K\+B\+::\+Msg\+Queue\+::\+Add\+Msg(), K\+K\+B\+::\+Msg\+Queue\+::\+Add\+Msgs(), Create\+And\+Start\+Block(), K\+K\+B\+::\+Msg\+Queue\+::\+Get\+All\+Msgs(), K\+K\+B\+::\+Msg\+Queue\+::\+Get\+Copy\+Of\+Last\+Msg(), K\+K\+B\+::\+Msg\+Queue\+::\+Get\+Next\+Msg(), and K\+K\+B\+::\+Msg\+Queue\+::\+Memory\+Consumed\+Estimated().


\begin{DoxyCode}
118 \{
119   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  curThreadId = \hyperlink{namespace_k_k_b_aa1d581b15163a41037c43bdbd800d0f8}{KKB::osGetThreadId} ();
120 
121   \textcolor{keywordflow}{if}  (blocked  &&  (curThreadId == blockerThreadId))
122   \{
123     ++levels;
124   \}
125   \textcolor{keywordflow}{else}
126   \{
127     CriticalSectionStart ();
128     levels = 1;
129     blockerThreadId = curThreadId;
130     blocked = \textcolor{keyword}{true};
131   \}
132 
133   \textcolor{keywordflow}{return};
134 \}   \textcolor{comment}{/* StartBlock */}
\end{DoxyCode}


\subsection{Friends And Related Function Documentation}
\index{K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}!K\+K\+Queue$<$ Goal\+Keeper\+Simple $>$@{K\+K\+Queue$<$ Goal\+Keeper\+Simple $>$}}
\index{K\+K\+Queue$<$ Goal\+Keeper\+Simple $>$@{K\+K\+Queue$<$ Goal\+Keeper\+Simple $>$}!K\+K\+B\+::\+Goal\+Keeper\+Simple@{K\+K\+B\+::\+Goal\+Keeper\+Simple}}
\subsubsection[{\texorpdfstring{K\+K\+Queue$<$ Goal\+Keeper\+Simple $>$}{KKQueue< GoalKeeperSimple >}}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf K\+K\+Queue}$<$ {\bf Goal\+Keeper\+Simple} $>$\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{class_k_k_b_1_1_goal_keeper_simple_a3c22ebe8b841379f92ef7cdfe3aed61c}{}\label{class_k_k_b_1_1_goal_keeper_simple_a3c22ebe8b841379f92ef7cdfe3aed61c}


Definition at line 41 of file Goal\+Keeper\+Simple.\+h.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/\+Kurt/\+Git\+Hub/\+K\+Square\+Libraries/\+K\+K\+Base/\hyperlink{_goal_keeper_simple_8h}{Goal\+Keeper\+Simple.\+h}\item 
C\+:/\+Users/\+Kurt/\+Git\+Hub/\+K\+Square\+Libraries/\+K\+K\+Base/\hyperlink{_goal_keeper_simple_8cpp}{Goal\+Keeper\+Simple.\+cpp}\end{DoxyCompactItemize}
