\hypertarget{class_k_k_b_1_1_msg_queue}{}\section{K\+KB\+:\+:Msg\+Queue Class Reference}
\label{class_k_k_b_1_1_msg_queue}\index{K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}}


Will manage a buffer that will allow multiple threads to add and remove messages to a queue.  




{\ttfamily \#include $<$Msg\+Queue.\+h$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{class_k_k_b_1_1_msg_queue}{Msg\+Queue} $\ast$ \hyperlink{class_k_k_b_1_1_msg_queue_a4799b7792832f5357e7679b252f7a750}{Msg\+Queue\+Ptr}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_k_k_b_1_1_msg_queue_aa6d7b73f9d84b27b1735c5964dea0595}{Msg\+Queue} (const \hyperlink{class_k_k_b_1_1_k_k_str}{K\+K\+Str} \&\+\_\+name)
\item 
\hyperlink{class_k_k_b_1_1_msg_queue_a04c1aca750c66393d3949d0b2aedc01c}{$\sim$\+Msg\+Queue} ()
\item 
void \hyperlink{class_k_k_b_1_1_msg_queue_a4d7d0adcf4f06a7afc6c8187a20bf95c}{Add\+Msg} (\hyperlink{namespace_k_k_b_a9adbef5a6b3be0867f5570df2a08f388}{K\+K\+Str\+Ptr} msg)
\begin{DoxyCompactList}\small\item\em Take ownership of \textquotesingle{}msg\textquotesingle{} and add to end of the queue. \end{DoxyCompactList}\item 
void \hyperlink{class_k_k_b_1_1_msg_queue_ac1356aec06472120e670bf39d6fdf91c}{Add\+Msg} (const \hyperlink{class_k_k_b_1_1_k_k_str}{K\+K\+Str} \&msg)
\item 
void \hyperlink{class_k_k_b_1_1_msg_queue_a7adf4ff13ee1e639140f7d717c7bd265}{Add\+Msgs} (const \hyperlink{namespace_k_k_b_a8f5f50672f37857425120831223888aa}{K\+K\+Str\+List\+Ptr} msgs, bool take\+Ownership)
\begin{DoxyCompactList}\small\item\em Adds the contents of \textquotesingle{}msgs\textquotesingle{} to the message queue and depending on \textquotesingle{}take\+Ownership\textquotesingle{} will either assume that its owns (taking ownership) the \hyperlink{class_k_k_b_1_1_k_k_str}{K\+K\+Str} instances or create duplicates. \end{DoxyCompactList}\item 
\hyperlink{namespace_k_k_b_a8f5f50672f37857425120831223888aa}{K\+K\+Str\+List\+Ptr} \hyperlink{class_k_k_b_1_1_msg_queue_ac0ba20e6b9f343c846f91233b8df082c}{Get\+All\+Msgs} ()
\begin{DoxyCompactList}\small\item\em Returns all messages that are currently in the queue. \end{DoxyCompactList}\item 
\hyperlink{namespace_k_k_b_a9adbef5a6b3be0867f5570df2a08f388}{K\+K\+Str\+Ptr} \hyperlink{class_k_k_b_1_1_msg_queue_aa010dbbc7fffe4ff07407d884c7a0f5e}{Get\+Copy\+Of\+Last\+Msg} ()
\begin{DoxyCompactList}\small\item\em Returns a duplicate of the last string added to the message queue. \end{DoxyCompactList}\item 
\hyperlink{namespace_k_k_b_a9adbef5a6b3be0867f5570df2a08f388}{K\+K\+Str\+Ptr} \hyperlink{class_k_k_b_1_1_msg_queue_a4e280303e6b11471624e1274cc681649}{Get\+Next\+Msg} ()
\begin{DoxyCompactList}\small\item\em Removes from the queue the oldest message added to the queue that has not been removed. \end{DoxyCompactList}\item 
\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32} \hyperlink{class_k_k_b_1_1_msg_queue_afe6ceeb9745ccf087a35eca6e83b026f}{Memory\+Consumed\+Estimated} ()
\begin{DoxyCompactList}\small\item\em Returns an estimate of the amount of memory consumed in bytes by this instance. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Will manage a buffer that will allow multiple threads to add and remove messages to a queue. 

A \textquotesingle{}Goal\+Keepeer\textquotesingle{} object \textquotesingle{}gate\+Keeper\textquotesingle{} will be used to enforce integrity in the Multi-\/\+Threaded environment. It will guarantee that only one thread at a time can access the Queue. 

Definition at line 19 of file Msg\+Queue.\+h.



\subsection{Member Typedef Documentation}
\index{K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}!Msg\+Queue\+Ptr@{Msg\+Queue\+Ptr}}
\index{Msg\+Queue\+Ptr@{Msg\+Queue\+Ptr}!K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}}
\subsubsection[{\texorpdfstring{Msg\+Queue\+Ptr}{MsgQueuePtr}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Msg\+Queue}$\ast$ {\bf K\+K\+B\+::\+Msg\+Queue\+::\+Msg\+Queue\+Ptr}}\hypertarget{class_k_k_b_1_1_msg_queue_a4799b7792832f5357e7679b252f7a750}{}\label{class_k_k_b_1_1_msg_queue_a4799b7792832f5357e7679b252f7a750}


Definition at line 22 of file Msg\+Queue.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}!Msg\+Queue@{Msg\+Queue}}
\index{Msg\+Queue@{Msg\+Queue}!K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}}
\subsubsection[{\texorpdfstring{Msg\+Queue(const K\+K\+Str \&\+\_\+name)}{MsgQueue(const KKStr &_name)}}]{\setlength{\rightskip}{0pt plus 5cm}Msg\+Queue\+::\+Msg\+Queue (
\begin{DoxyParamCaption}
\item[{const {\bf K\+K\+Str} \&}]{\+\_\+name}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_msg_queue_aa6d7b73f9d84b27b1735c5964dea0595}{}\label{class_k_k_b_1_1_msg_queue_aa6d7b73f9d84b27b1735c5964dea0595}


Definition at line 29 of file Msg\+Queue.\+cpp.



References K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+Create(), K\+K\+B\+::\+K\+K\+Str\+::\+K\+K\+Str(), K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+Memory\+Consumed\+Estimated(), Msg\+Queue(), and K\+K\+B\+::operator+().



Referenced by Msg\+Queue().


\begin{DoxyCode}
29                                       :        \textcolor{comment}{/* Name of buffer, must be unique */}
30     gateKeeper     (NULL),
31     memoryConsumed (0),
32     name           (\_name),
33     queue          ()
34 \{
35   \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a7001b3a689776a4ef2b56219f965b26c}{GoalKeeperSimple::Create} (\textcolor{stringliteral}{"MsgQueue\_"} + name, gateKeeper);
36   memoryConsumed = \textcolor{keyword}{sizeof} (\hyperlink{class_k_k_b_1_1_msg_queue_aa6d7b73f9d84b27b1735c5964dea0595}{MsgQueue}) + gateKeeper->
      \hyperlink{class_k_k_b_1_1_goal_keeper_simple_a89e05c58c7d851dc6ad858803c37309a}{MemoryConsumedEstimated} ();
37 \}
\end{DoxyCode}
\index{K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}!````~Msg\+Queue@{$\sim$\+Msg\+Queue}}
\index{````~Msg\+Queue@{$\sim$\+Msg\+Queue}!K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}}
\subsubsection[{\texorpdfstring{$\sim$\+Msg\+Queue()}{~MsgQueue()}}]{\setlength{\rightskip}{0pt plus 5cm}Msg\+Queue\+::$\sim$\+Msg\+Queue (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_msg_queue_a04c1aca750c66393d3949d0b2aedc01c}{}\label{class_k_k_b_1_1_msg_queue_a04c1aca750c66393d3949d0b2aedc01c}


Definition at line 41 of file Msg\+Queue.\+cpp.



References K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+Destroy().


\begin{DoxyCode}
42 \{
43   \textcolor{keywordflow}{while}  (this->queue.size () > 0)
44   \{
45     \hyperlink{class_k_k_b_1_1_k_k_str}{KKStrPtr}  m = this->queue.front ();
46     this->queue.pop ();
47     \textcolor{keyword}{delete}  m;  
48     m = NULL;
49   \}
50 
51   \hyperlink{class_k_k_b_1_1_goal_keeper_simple_aa1098674662d5e6a03fb4af27e1c5af5}{GoalKeeperSimple::Destroy} (gateKeeper);  
52   gateKeeper = NULL;
53 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}!Add\+Msg@{Add\+Msg}}
\index{Add\+Msg@{Add\+Msg}!K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}}
\subsubsection[{\texorpdfstring{Add\+Msg(\+K\+K\+Str\+Ptr msg)}{AddMsg(KKStrPtr msg)}}]{\setlength{\rightskip}{0pt plus 5cm}void Msg\+Queue\+::\+Add\+Msg (
\begin{DoxyParamCaption}
\item[{{\bf K\+K\+Str\+Ptr}}]{msg}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_msg_queue_a4d7d0adcf4f06a7afc6c8187a20bf95c}{}\label{class_k_k_b_1_1_msg_queue_a4d7d0adcf4f06a7afc6c8187a20bf95c}


Take ownership of \textquotesingle{}msg\textquotesingle{} and add to end of the queue. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em msg} & Pointer to message that is to be added to end of queue. The caller will pass ownership of this string to this instance of Msg\+Queue.\+Taking ownership of \textquotesingle{}msg\textquotesingle{} \\
\hline
\end{DoxyParams}


Definition at line 58 of file Msg\+Queue.\+cpp.



References K\+K\+B\+::\+K\+K\+Str\+::\+Concat(), K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+End\+Block(), K\+K\+B\+::\+K\+K\+Exception\+::\+K\+K\+Exception(), K\+K\+B\+::\+K\+K\+Str\+::\+Memory\+Consumed\+Estimated(), and K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+Start\+Block().



Referenced by K\+K\+B\+::\+K\+K\+Thread\+::\+Add\+Msg().


\begin{DoxyCode}
59 \{
60   \textcolor{keywordflow}{if}  (msg == NULL)
61   \{
62     \hyperlink{class_k_k_b_1_1_k_k_str}{KKStr}  errMsg;
63     errMsg << \textcolor{stringliteral}{"MsgQueue::AddMsg ==  NULL"};
64     cerr << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl} << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl} << errMsg << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl} << 
      \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
65     \textcolor{keywordflow}{throw} \hyperlink{class_k_k_b_1_1_k_k_exception}{KKException} (errMsg);
66   \}
67 
68   gateKeeper->\hyperlink{class_k_k_b_1_1_goal_keeper_simple_aa8bcf9dcd7f07275aaac8ecdedac8cb1}{StartBlock} ();
69   queue.push (msg);
70   memoryConsumed = memoryConsumed +  msg->\hyperlink{class_k_k_b_1_1_k_k_str_afc335bf98a8d4a77dc34215e72068719}{MemoryConsumedEstimated} ();
71   gateKeeper->\hyperlink{class_k_k_b_1_1_goal_keeper_simple_a28a529882f7ace4f8300508d4dee9c3e}{EndBlock} ();
72 \}  \textcolor{comment}{/* AddFrame */}
\end{DoxyCode}
\index{K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}!Add\+Msg@{Add\+Msg}}
\index{Add\+Msg@{Add\+Msg}!K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}}
\subsubsection[{\texorpdfstring{Add\+Msg(const K\+K\+Str \&msg)}{AddMsg(const KKStr &msg)}}]{\setlength{\rightskip}{0pt plus 5cm}void Msg\+Queue\+::\+Add\+Msg (
\begin{DoxyParamCaption}
\item[{const {\bf K\+K\+Str} \&}]{msg}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_msg_queue_ac1356aec06472120e670bf39d6fdf91c}{}\label{class_k_k_b_1_1_msg_queue_ac1356aec06472120e670bf39d6fdf91c}


Definition at line 76 of file Msg\+Queue.\+cpp.



References K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+End\+Block(), K\+K\+B\+::\+K\+K\+Str\+::\+Memory\+Consumed\+Estimated(), and K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+Start\+Block().



Referenced by K\+K\+B\+::\+K\+K\+Thread\+::\+Add\+Msg(), and K\+K\+B\+::\+Run\+Log\+::\+Write\+Line().


\begin{DoxyCode}
77 \{
78   gateKeeper->\hyperlink{class_k_k_b_1_1_goal_keeper_simple_aa8bcf9dcd7f07275aaac8ecdedac8cb1}{StartBlock} ();
79   queue.push (\textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_k_k_str}{KKStr} (msg));
80   memoryConsumed = memoryConsumed + msg.\hyperlink{class_k_k_b_1_1_k_k_str_afc335bf98a8d4a77dc34215e72068719}{MemoryConsumedEstimated} ();
81   gateKeeper->\hyperlink{class_k_k_b_1_1_goal_keeper_simple_a28a529882f7ace4f8300508d4dee9c3e}{EndBlock} ();
82 \}  \textcolor{comment}{/* AddFrame */}
\end{DoxyCode}
\index{K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}!Add\+Msgs@{Add\+Msgs}}
\index{Add\+Msgs@{Add\+Msgs}!K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}}
\subsubsection[{\texorpdfstring{Add\+Msgs(const K\+K\+Str\+List\+Ptr msgs, bool take\+Ownership)}{AddMsgs(const KKStrListPtr msgs, bool takeOwnership)}}]{\setlength{\rightskip}{0pt plus 5cm}void Msg\+Queue\+::\+Add\+Msgs (
\begin{DoxyParamCaption}
\item[{const {\bf K\+K\+Str\+List\+Ptr}}]{msgs, }
\item[{bool}]{take\+Ownership}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_msg_queue_a7adf4ff13ee1e639140f7d717c7bd265}{}\label{class_k_k_b_1_1_msg_queue_a7adf4ff13ee1e639140f7d717c7bd265}


Adds the contents of \textquotesingle{}msgs\textquotesingle{} to the message queue and depending on \textquotesingle{}take\+Ownership\textquotesingle{} will either assume that its owns (taking ownership) the \hyperlink{class_k_k_b_1_1_k_k_str}{K\+K\+Str} instances or create duplicates. 

If \textquotesingle{}take\+Ownership\textquotesingle{} is true will and the \hyperlink{class_k_k_b_1_1_k_k_str}{K\+K\+Str} instances in \textquotesingle{}msgs\textquotesingle{} to the queue otherwise it will make duplicates of the \hyperlink{class_k_k_b_1_1_k_k_str}{K\+K\+Str} instances. It is up to the caller to make sure that they set the Owner flag on the \textquotesingle{}msgs\textquotesingle{} instance; for example if \textquotesingle{}take\+Ownership\textquotesingle{} is \textquotesingle{}true\textquotesingle{} then caller should set \textquotesingle{}msgs.\+Owner (false);\textquotesingle{}. 

Definition at line 86 of file Msg\+Queue.\+cpp.



References K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+End\+Block(), K\+K\+B\+::\+K\+K\+Str\+::\+Memory\+Consumed\+Estimated(), and K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+Start\+Block().


\begin{DoxyCode}
89 \{
90   gateKeeper->\hyperlink{class_k_k_b_1_1_goal_keeper_simple_aa8bcf9dcd7f07275aaac8ecdedac8cb1}{StartBlock} ();
91   \hyperlink{class_k_k_b_1_1_k_k_queue_aa3c2796a726eea468b94132a9fbf2cfe}{KKStrList::iterator} idx;
92   \textcolor{keywordflow}{for}  (idx = msgs->begin ();  idx != msgs->end ();  ++idx)
93   \{
94     \hyperlink{class_k_k_b_1_1_k_k_str}{KKStrPtr}  msg = *idx;
95     \textcolor{keywordflow}{if}  (takeOwnership)
96       queue.push (msg);
97     \textcolor{keywordflow}{else}
98       queue.push (\textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_k_k_str}{KKStr} (*msg));
99 
100     memoryConsumed = memoryConsumed + msg->\hyperlink{class_k_k_b_1_1_k_k_str_afc335bf98a8d4a77dc34215e72068719}{MemoryConsumedEstimated} ();
101   \}
102   gateKeeper->\hyperlink{class_k_k_b_1_1_goal_keeper_simple_a28a529882f7ace4f8300508d4dee9c3e}{EndBlock} ();
103 \}
\end{DoxyCode}
\index{K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}!Get\+All\+Msgs@{Get\+All\+Msgs}}
\index{Get\+All\+Msgs@{Get\+All\+Msgs}!K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}}
\subsubsection[{\texorpdfstring{Get\+All\+Msgs()}{GetAllMsgs()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf K\+K\+Str\+List\+Ptr} Msg\+Queue\+::\+Get\+All\+Msgs (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_msg_queue_ac0ba20e6b9f343c846f91233b8df082c}{}\label{class_k_k_b_1_1_msg_queue_ac0ba20e6b9f343c846f91233b8df082c}


Returns all messages that are currently in the queue. 



Definition at line 125 of file Msg\+Queue.\+cpp.



References K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+End\+Block(), K\+K\+B\+::\+K\+K\+Str\+List\+::\+K\+K\+Str\+List(), and K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+Start\+Block().


\begin{DoxyCode}
126 \{
127   \hyperlink{class_k_k_b_1_1_k_k_str_list}{KKStrListPtr}  result = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_k_k_str_list}{KKStrList} ();
128   gateKeeper->\hyperlink{class_k_k_b_1_1_goal_keeper_simple_aa8bcf9dcd7f07275aaac8ecdedac8cb1}{StartBlock} ();
129 
130   \hyperlink{class_k_k_b_1_1_k_k_str}{KKStrPtr}  msg = NULL;
131   \textcolor{keywordflow}{while}  (queue.size () > 0)
132   \{
133     msg = queue.front ();
134     queue.pop ();
135     result->\hyperlink{class_k_k_b_1_1_k_k_queue_aa9fba4632b54268bf71ecb42dee0b575}{PushOnBack} (msg);
136     memoryConsumed = memoryConsumed - msg->\hyperlink{class_k_k_b_1_1_k_k_str_afc335bf98a8d4a77dc34215e72068719}{MemoryConsumedEstimated} ();
137   \}
138 
139   gateKeeper->\hyperlink{class_k_k_b_1_1_goal_keeper_simple_a28a529882f7ace4f8300508d4dee9c3e}{EndBlock} ();
140 
141   \textcolor{keywordflow}{return}  result;
142 \}  \textcolor{comment}{/* GetAllMsgs */}
\end{DoxyCode}
\index{K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}!Get\+Copy\+Of\+Last\+Msg@{Get\+Copy\+Of\+Last\+Msg}}
\index{Get\+Copy\+Of\+Last\+Msg@{Get\+Copy\+Of\+Last\+Msg}!K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}}
\subsubsection[{\texorpdfstring{Get\+Copy\+Of\+Last\+Msg()}{GetCopyOfLastMsg()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf K\+K\+Str\+Ptr} Msg\+Queue\+::\+Get\+Copy\+Of\+Last\+Msg (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_msg_queue_aa010dbbc7fffe4ff07407d884c7a0f5e}{}\label{class_k_k_b_1_1_msg_queue_aa010dbbc7fffe4ff07407d884c7a0f5e}


Returns a duplicate of the last string added to the message queue. 

This will not effect the current copy of the message queue. The returned string will be owned by the caller who will be responsible for deleting it. 

Definition at line 157 of file Msg\+Queue.\+cpp.



References K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+End\+Block(), and K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+Start\+Block().


\begin{DoxyCode}
158 \{
159   \hyperlink{class_k_k_b_1_1_k_k_str}{KKStrPtr}  msg = NULL;
160   gateKeeper->\hyperlink{class_k_k_b_1_1_goal_keeper_simple_aa8bcf9dcd7f07275aaac8ecdedac8cb1}{StartBlock} ();
161   \textcolor{keywordflow}{if}  (queue.size () > 0)
162   \{
163     msg = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_k_k_str}{KKStr} (*(queue.back ()));
164   \}
165   gateKeeper->\hyperlink{class_k_k_b_1_1_goal_keeper_simple_a28a529882f7ace4f8300508d4dee9c3e}{EndBlock} ();
166   \textcolor{keywordflow}{return}  msg;
167 \}
\end{DoxyCode}
\index{K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}!Get\+Next\+Msg@{Get\+Next\+Msg}}
\index{Get\+Next\+Msg@{Get\+Next\+Msg}!K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}}
\subsubsection[{\texorpdfstring{Get\+Next\+Msg()}{GetNextMsg()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf K\+K\+Str\+Ptr} Msg\+Queue\+::\+Get\+Next\+Msg (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_msg_queue_a4e280303e6b11471624e1274cc681649}{}\label{class_k_k_b_1_1_msg_queue_a4e280303e6b11471624e1274cc681649}


Removes from the queue the oldest message added to the queue that has not been removed. 

The caller will get ownership of the string and be responsible for deleting it. 

Definition at line 107 of file Msg\+Queue.\+cpp.



References K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+End\+Block(), and K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+Start\+Block().



Referenced by K\+K\+B\+::\+K\+K\+Thread\+::\+Get\+Msgs().


\begin{DoxyCode}
108 \{
109   gateKeeper->\hyperlink{class_k_k_b_1_1_goal_keeper_simple_aa8bcf9dcd7f07275aaac8ecdedac8cb1}{StartBlock} ();
110 
111   \hyperlink{class_k_k_b_1_1_k_k_str}{KKStrPtr}  msg = NULL;
112   \textcolor{keywordflow}{if}  (queue.size () > 0)
113   \{
114     msg = queue.front ();
115     queue.pop ();
116     memoryConsumed = memoryConsumed - msg->\hyperlink{class_k_k_b_1_1_k_k_str_afc335bf98a8d4a77dc34215e72068719}{MemoryConsumedEstimated} ();
117   \}
118 
119   gateKeeper->\hyperlink{class_k_k_b_1_1_goal_keeper_simple_a28a529882f7ace4f8300508d4dee9c3e}{EndBlock} ();
120   \textcolor{keywordflow}{return}  msg;
121 \}  \textcolor{comment}{/* GetNextMsg */}
\end{DoxyCode}
\index{K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}!Memory\+Consumed\+Estimated@{Memory\+Consumed\+Estimated}}
\index{Memory\+Consumed\+Estimated@{Memory\+Consumed\+Estimated}!K\+K\+B\+::\+Msg\+Queue@{K\+K\+B\+::\+Msg\+Queue}}
\subsubsection[{\texorpdfstring{Memory\+Consumed\+Estimated()}{MemoryConsumedEstimated()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf kkint32} Msg\+Queue\+::\+Memory\+Consumed\+Estimated (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_msg_queue_afe6ceeb9745ccf087a35eca6e83b026f}{}\label{class_k_k_b_1_1_msg_queue_afe6ceeb9745ccf087a35eca6e83b026f}


Returns an estimate of the amount of memory consumed in bytes by this instance. 

This will help managed objects keep track of how much memory they are using in the unmanaged world. 

Definition at line 146 of file Msg\+Queue.\+cpp.



References K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+End\+Block(), and K\+K\+B\+::\+Goal\+Keeper\+Simple\+::\+Start\+Block().



Referenced by K\+K\+B\+::\+K\+K\+Thread\+::\+Memory\+Consumed\+Estimated().


\begin{DoxyCode}
147 \{
148   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  result = 0;
149   gateKeeper->\hyperlink{class_k_k_b_1_1_goal_keeper_simple_aa8bcf9dcd7f07275aaac8ecdedac8cb1}{StartBlock} ();
150   result = memoryConsumed;
151   gateKeeper->\hyperlink{class_k_k_b_1_1_goal_keeper_simple_a28a529882f7ace4f8300508d4dee9c3e}{EndBlock} ();
152   \textcolor{keywordflow}{return}  result;
153 \}  \textcolor{comment}{/* MemoryConsumedEstimated */}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/\+Kurt/\+Git\+Hub/\+K\+Square\+Libraries/\+K\+K\+Base/\hyperlink{_msg_queue_8h}{Msg\+Queue.\+h}\item 
C\+:/\+Users/\+Kurt/\+Git\+Hub/\+K\+Square\+Libraries/\+K\+K\+Base/\hyperlink{_msg_queue_8cpp}{Msg\+Queue.\+cpp}\end{DoxyCompactItemize}
