\hypertarget{class_k_k_b_1_1_compressor}{}\section{K\+KB\+:\+:Compressor Class Reference}
\label{class_k_k_b_1_1_compressor}\index{K\+K\+B\+::\+Compressor@{K\+K\+B\+::\+Compressor}}


Simple class that will compress and decompress specified buffers using the routines provided in zlib.  




{\ttfamily \#include $<$Compressor.\+h$>$}

\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void $\ast$ \hyperlink{class_k_k_b_1_1_compressor_a1f70b55127cc45c05f57d58595e9d2f1}{Create\+Compressed\+Buffer} (void $\ast$source, \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} source\+Len, \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} \&compressed\+Buff\+Len)
\item 
static void $\ast$ \hyperlink{class_k_k_b_1_1_compressor_a2a6621b98a88b60530ab344c25177b65}{Decompress} (const void $\ast$compressed\+Buff, \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} compressed\+Buff\+Len, \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} \&un\+Compressed\+Len)
\item 
static void \hyperlink{class_k_k_b_1_1_compressor_a9b64a1ab2887f338b1f14351c30a118e}{Decompress} (const void $\ast$compressed\+Buff, \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} compressed\+Buff\+Len, \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar} $\ast$\&un\+Compressed\+Buff, \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} \&un\+Compressed\+Buff\+Size, \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} \&un\+Compressed\+Buff\+Len)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Simple class that will compress and decompress specified buffers using the routines provided in zlib. 

\begin{DoxyAuthor}{Author}
Kurt Kramer 
\end{DoxyAuthor}


Definition at line 17 of file Compressor.\+h.



\subsection{Member Function Documentation}
\index{K\+K\+B\+::\+Compressor@{K\+K\+B\+::\+Compressor}!Create\+Compressed\+Buffer@{Create\+Compressed\+Buffer}}
\index{Create\+Compressed\+Buffer@{Create\+Compressed\+Buffer}!K\+K\+B\+::\+Compressor@{K\+K\+B\+::\+Compressor}}
\subsubsection[{\texorpdfstring{Create\+Compressed\+Buffer(void $\ast$source, kkuint32 source\+Len, kkuint32 \&compressed\+Buff\+Len)}{CreateCompressedBuffer(void *source, kkuint32 sourceLen, kkuint32 &compressedBuffLen)}}]{\setlength{\rightskip}{0pt plus 5cm}void $\ast$ Compressor\+::\+Create\+Compressed\+Buffer (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{source, }
\item[{{\bf kkuint32}}]{source\+Len, }
\item[{{\bf kkuint32} \&}]{compressed\+Buff\+Len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_k_k_b_1_1_compressor_a1f70b55127cc45c05f57d58595e9d2f1}{}\label{class_k_k_b_1_1_compressor_a1f70b55127cc45c05f57d58595e9d2f1}


Definition at line 22 of file Compressor.\+cpp.



Referenced by K\+K\+B\+::\+Raster\+::\+To\+Compressor().


\begin{DoxyCode}
26 \{
27 \textcolor{preprocessor}{#ifdef ZLIB\_H}
28 
29   \textcolor{comment}{// following code was lifted from example provided by zlib  "zpipe.c"}
30   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}   ret;
31   z\_stream  strm;
32 
33 
34   Bytef*  outputBuffer = NULL;
35   \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32}  outputBufferSize = sourceLen * 2;
36 
37   outputBuffer = \textcolor{keyword}{new} Bytef[outputBufferSize];
38 
39   \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  compressedBuff = NULL;
40   compressedBuffLen     = 0;
41 
42   \textcolor{comment}{//  The first thing we do is to initialize the zlib state for compression using deflateInit(). This must
       be done}
43   \textcolor{comment}{// before the first use of deflate(). The zalloc, zfree, and opaque fields in the strm structure must be
       initialized}
44   \textcolor{comment}{// before calling deflateInit(). Here they are set to the zlib constant Z\_NULL to request that zlib use
       the default}
45   \textcolor{comment}{// memory allocation routines. An application may also choose to provide custom memory allocation
       routines here.}
46   \textcolor{comment}{// deflateInit() will allocate on the order of 256K bytes for the internal state. (See zlib Technical
       Details.)}
47   \textcolor{comment}{// deflateInit() is called with a pointer to the structure to be initialized and the compression level,
       which is}
48   \textcolor{comment}{// an integer in the range of -1 to 9. Lower compression levels result in faster execution, but less
       compression.}
49   \textcolor{comment}{// Higher levels result in greater compression, but slower execution. The zlib constant
       Z\_DEFAULT\_COMPRESSION, equal}
50   \textcolor{comment}{// to -1, provides a good compromise between compression and speed and is equivalent to level 6. Level 0
       actually}
51   \textcolor{comment}{// does no compression at all, and in fact expands the data slightly to produce the zlib format (it is
       not a}
52   \textcolor{comment}{// byte-for-byte copy of the input). More advanced applications of zlib may use deflateInit2() here
       instead. Such an}
53   \textcolor{comment}{// application may want to reduce how much memory will be used, at some price in compression. Or it may
       need to request}
54   \textcolor{comment}{// a gzip header and trailer instead of a zlib header and trailer, or raw encoding with no header or
       trailer at all.}
55 
56   \textcolor{comment}{// We must check the return value of deflateInit() against the zlib constant Z\_OK to make sure that it
       was able to}
57   \textcolor{comment}{// allocate memory for the internal state, and that the provided arguments were valid. deflateInit() will
       also check}
58   \textcolor{comment}{// that the version of zlib that the zlib.h file came from matches the version of zlib actually linked
       with the}
59   \textcolor{comment}{// program. This is especially important for environments in which zlib is a shared library.}
60 
61   \textcolor{comment}{// Note that an application can initialize multiple, independent zlib streams, which can operate in
       parallel. The state}
62   \textcolor{comment}{// information maintained in the structure allows the zlib routines to be reentrant.}
63 
64 
65   \textcolor{comment}{/* allocate deflate state */}
66   strm.zalloc  = Z\_NULL;
67   strm.zfree   = Z\_NULL;
68   strm.opaque  = Z\_NULL;
69   ret = deflateInit (&strm, Z\_DEFAULT\_COMPRESSION);   \textcolor{comment}{// 'Z\_DEFAULT\_COMPRESSION' will balance between speed
       and compression;  0 = no compression,  9 = best compression}
70   \textcolor{keywordflow}{if}  (ret != Z\_OK)
71   \{
72     \textcolor{comment}{// Initialization Failed}
73     compressedBuffLen = 0;
74     \textcolor{keywordflow}{return} NULL;
75   \}
76 
77   \textcolor{comment}{//  With the pleasantries out of the way, now we can get down to business. The outer do-loop reads all of
       the input}
78   \textcolor{comment}{// file and exits at the bottom of the loop once end-of-file is reached. This loop contains the only call
       of deflate().}
79   \textcolor{comment}{// So we must make sure that all of the input data has been processed and that all of the output data has
       been generated}
80   \textcolor{comment}{// and consumed before we fall out of the loop at the bottom.}
81 
82   \{
83     \textcolor{comment}{// This was originally a a loop that read from a file;  but now we have a input buffer with a known
       amount of data.}
84     strm.avail\_in = sourceLen;       \textcolor{comment}{// Number of bytes in 'source'  to compress.}
85     strm.next\_in  = (Bytef*)source;  \textcolor{comment}{// pointer to data that needs to be compressed.}
86     
87     \textcolor{keywordflow}{do}
88     \{ 
89       \textcolor{comment}{// We will stay in this loop until all data in source is processed.  If the output buffer is not
       large enough }
90       \textcolor{comment}{// we may need to make more than one iteration.}
91 
92       strm.avail\_out = outputBufferSize;
93       strm.next\_out  = outputBuffer;
94       
95       \textcolor{comment}{// Now we call the compression engine itself, deflate(). It takes as many of the avail\_in bytes at
       next\_in as it can}
96       \textcolor{comment}{// process, and writes as many as avail\_out bytes to next\_out. Those counters and pointers are then
       updated past the}
97       \textcolor{comment}{// input data consumed and the output data written. It is the amount of output space available that
       may limit how much}
98       \textcolor{comment}{// input is consumed. Hence the inner loop to make sure that all of the input is consumed by
       providing more output}
99       \textcolor{comment}{// space each time. Since avail\_in and next\_in are updated by deflate(), we don't have to mess with
       those between}
100       \textcolor{comment}{// deflate() calls until it's all used up.}
101 
102       \textcolor{comment}{// The parameters to deflate() are a pointer to the stream structure containing the input and output
       information and}
103       \textcolor{comment}{// the internal compression engine state, and a parameter indicating whether and how to flush data to
       the output.}
104       \textcolor{comment}{// Normally deflate will consume several K bytes of input data before producing any output (except
       for the header),}
105       \textcolor{comment}{// in order to accumulate statistics on the data for optimum compression. It will then put out a
       burst of compressed}
106       \textcolor{comment}{// data, and proceed to consume more input before the next burst. Eventually, deflate() must be told
       to terminate the}
107       \textcolor{comment}{// stream, complete the compression with provided input data, and write out the trailer check value.
       deflate() will}
108       \textcolor{comment}{// continue to compress normally as long as the flush parameter is Z\_NO\_FLUSH. Once the Z\_FINISH
       parameter is provided,}
109       \textcolor{comment}{// deflate() will begin to complete the compressed output stream. However depending on how much
       output space is}
110       \textcolor{comment}{// provided, deflate() may have to be called several times until it has provided the complete
       compressed stream, even}
111       \textcolor{comment}{// after it has consumed all of the input. The flush parameter must continue to be Z\_FINISH for those
       subsequent calls.}
112 
113       ret = deflate (&strm, Z\_FINISH);
114       \textcolor{keywordflow}{if}  (ret == Z\_STREAM\_ERROR)
115       \{
116         cerr << \textcolor{stringliteral}{"Compressor::CreateCompressedBuffer  ***ERROR**   deflate returned error["} << ret << \textcolor{stringliteral}{"]."} <
      < \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
117         compressedBuffLen = 0;
118         \textcolor{keywordflow}{return} NULL;
119       \}
120       
121       \textcolor{comment}{// Now we compute how much output deflate() provided on the last call, which is the difference
       between how much space}
122       \textcolor{comment}{// was provided before the call, and how much output space is still available after the call. Then
       that data, if any,}
123       \textcolor{comment}{// is written to the output file. We can then reuse the output buffer for the next call of deflate().
       Again if there}
124       \textcolor{comment}{// is a file i/o error, we call deflateEnd() before returning to avoid a memory leak.}
125       \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32} have = outputBufferSize - strm.avail\_out;
126       \{
127         \textcolor{keywordflow}{if}  (compressedBuff == NULL)
128         \{
129           compressedBuff = \textcolor{keyword}{new} \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}[have];
130           compressedBuffLen = have;
131           memcpy (compressedBuff, outputBuffer, have);
132         \}
133         \textcolor{keywordflow}{else}
134         \{
135           \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32}  newCompressedBuffLen = compressedBuffLen + have;
136           \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  newCompressedBuff = \textcolor{keyword}{new} \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}[newCompressedBuffLen];
137           memcpy (newCompressedBuff, compressedBuff, compressedBuffLen);
138           memcpy (newCompressedBuff + compressedBuffLen, outputBuffer, have);
139           \textcolor{keyword}{delete}[]  compressedBuff;
140           compressedBuff    = newCompressedBuff;
141           compressedBuffLen = newCompressedBuffLen;
142         \}
143       \}
144     \} \textcolor{keywordflow}{while} (strm.avail\_out == 0);
145    
146 
147     \textcolor{keywordflow}{if}  (strm.avail\_in != 0)
148     \{
149       \textcolor{comment}{// There is still input data;  so something went wrong. We will prompt a diagnostic message and
       return NULL}
150       cerr << \textcolor{stringliteral}{"Compressor::CreateCompressedBuffer   -  The input buffer was not fully processed."} << 
      \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
151       \textcolor{keyword}{delete}[]  compressedBuff;  compressedBuff  = NULL;
152       \textcolor{keyword}{delete}[]  outputBuffer;    outputBuffer    = NULL;
153       \textcolor{keywordflow}{return}  NULL;
154     \}
155   \}
156 
157   \textcolor{comment}{// The process is complete, but we still need to deallocate the state to avoid a memory leak (or rather
       more like a memory}
158   \textcolor{comment}{// hemorrhage if you didn't do this). Then finally we can return with a happy return value.}
159   \textcolor{comment}{/* clean up and return */}
160  (void)deflateEnd (&strm);
161 
162  \textcolor{keyword}{delete}[]  outputBuffer;  outputBuffer = NULL;
163 
164  \textcolor{keywordflow}{return}  compressedBuff;
165 
166 \textcolor{preprocessor}{#else}
167  \textcolor{comment}{// For right now the linux version will not be doing compression.}
168  \textcolor{keywordflow}{return}  NULL;
169 \textcolor{preprocessor}{#endif}
170 \}   \textcolor{comment}{/* CreateCompressedBuffer*/}
\end{DoxyCode}
\index{K\+K\+B\+::\+Compressor@{K\+K\+B\+::\+Compressor}!Decompress@{Decompress}}
\index{Decompress@{Decompress}!K\+K\+B\+::\+Compressor@{K\+K\+B\+::\+Compressor}}
\subsubsection[{\texorpdfstring{Decompress(const void $\ast$compressed\+Buff, kkuint32 compressed\+Buff\+Len, kkuint32 \&un\+Compressed\+Len)}{Decompress(const void *compressedBuff, kkuint32 compressedBuffLen, kkuint32 &unCompressedLen)}}]{\setlength{\rightskip}{0pt plus 5cm}void $\ast$ Compressor\+::\+Decompress (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{compressed\+Buff, }
\item[{{\bf kkuint32}}]{compressed\+Buff\+Len, }
\item[{{\bf kkuint32} \&}]{un\+Compressed\+Len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_k_k_b_1_1_compressor_a2a6621b98a88b60530ab344c25177b65}{}\label{class_k_k_b_1_1_compressor_a2a6621b98a88b60530ab344c25177b65}


Definition at line 177 of file Compressor.\+cpp.



References K\+K\+B\+::\+Global\+Goal\+Keeper\+::\+End\+Block(), and K\+K\+B\+::\+Global\+Goal\+Keeper\+::\+Start\+Block().



Referenced by K\+K\+B\+::\+Raster\+::\+From\+Compressor().


\begin{DoxyCode}
181 \{
182 \textcolor{preprocessor}{#ifdef ZLIB\_H}
183   \textcolor{keywordflow}{if}  (compressedBuff == NULL)
184     \textcolor{keywordflow}{return}  NULL;
185 
186   \hyperlink{class_k_k_b_1_1_global_goal_keeper_a05d7aab73a0cc12c01f4dd6e8d3da839}{GlobalGoalKeeper::StartBlock} ();
187 
188   \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32}   have              = 0;
189   \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*     unCompressedBuff  = NULL;
190 
191   Bytef*     outBuffer    = NULL;
192   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}    outBufferLen = 0;
193 
194   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}    ret;
195   z\_stream   strm;
196 
197   \textcolor{comment}{/* allocate inflate state */}
198   strm.zalloc   = Z\_NULL;
199   strm.zfree    = Z\_NULL;
200   strm.opaque   = Z\_NULL;
201   strm.avail\_in = 0;
202   strm.next\_in  = Z\_NULL;
203 
204   ret = inflateInit (&strm);
205   \textcolor{keywordflow}{if}  (ret != Z\_OK)
206   \{
207     cerr << \textcolor{stringliteral}{"Compressor::Decompress  ***ERROR***  zlib function call 'inflateInit'  failed."} << 
      \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
208     unCompressedLen = 0;
209     \hyperlink{class_k_k_b_1_1_global_goal_keeper_a4e03a2807ca2f00c359da8625afb4cc5}{GlobalGoalKeeper::EndBlock} ();
210     \textcolor{keywordflow}{return} NULL;
211   \}
212 
213 
214   outBufferLen = compressedBuffLen * 4;
215   outBuffer    = \textcolor{keyword}{new} Bytef[outBufferLen];
216 
217   strm.avail\_in = compressedBuffLen;
218   strm.next\_in  = (Bytef*)compressedBuff;  \textcolor{comment}{// Bytef = a far pointer to a unsigned char.    }
219                                            \textcolor{comment}{// Not sure if on some platforms this may cause a problem.}
220 
221   \textcolor{comment}{/* run inflate() on input until output buffer not full */}
222   \textcolor{keywordflow}{do} 
223   \{
224     strm.avail\_out = outBufferLen;
225     strm.next\_out  = outBuffer;
226 
227     ret = inflate (&strm, Z\_NO\_FLUSH);
228     \textcolor{keywordflow}{if}  (ret == Z\_STREAM\_ERROR)
229     \{
230       cerr << \textcolor{stringliteral}{"Compressor::Decompress  ***ERROR***  zlib function call 'inflate'  failed."}  << 
      \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
231       \textcolor{keyword}{delete}[]  outBuffer;  outBuffer = NULL;
232       \textcolor{keyword}{delete}[]  unCompressedBuff;     unCompressedBuff    = NULL;
233       unCompressedLen = 0;
234       \hyperlink{class_k_k_b_1_1_global_goal_keeper_a4e03a2807ca2f00c359da8625afb4cc5}{GlobalGoalKeeper::EndBlock} ();
235       \textcolor{keywordflow}{return} NULL;
236     \}
237 
238     \textcolor{keywordflow}{switch} (ret) 
239     \{
240     \textcolor{keywordflow}{case} Z\_NEED\_DICT:  ret = Z\_DATA\_ERROR;     \textcolor{comment}{/* and fall through */}
241     \textcolor{keywordflow}{case} Z\_DATA\_ERROR:
242     \textcolor{keywordflow}{case} Z\_MEM\_ERROR:
243       \{
244         cerr << \textcolor{stringliteral}{"Compressor::Decompress  ***ERROR***  zlib function call 'inflate'  failed."}  << 
      \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
245         (void)inflateEnd (&strm);
246         \textcolor{keyword}{delete}[]  outBuffer;          outBuffer        = NULL;
247         \textcolor{keyword}{delete}[]  unCompressedBuff;   unCompressedBuff = NULL;
248         unCompressedLen = 0;
249         \hyperlink{class_k_k_b_1_1_global_goal_keeper_a4e03a2807ca2f00c359da8625afb4cc5}{GlobalGoalKeeper::EndBlock} ();
250         \textcolor{keywordflow}{return} NULL;
251       \}
252     \}
253 
254     have = outBufferLen - strm.avail\_out;
255     \textcolor{keywordflow}{if}  (unCompressedBuff == NULL)
256     \{
257       unCompressedBuff = \textcolor{keyword}{new} \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}[have];
258       unCompressedLen = have;
259       memcpy (unCompressedBuff, outBuffer, have);
260     \}
261     \textcolor{keywordflow}{else}
262     \{
263       \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  newUnCompressedLen = unCompressedLen + have;
264       \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}* newUnCompressedBuff  = \textcolor{keyword}{new} \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}[newUnCompressedLen];
265       memcpy (newUnCompressedBuff, unCompressedBuff, unCompressedLen);
266       memcpy (newUnCompressedBuff + unCompressedLen, outBuffer, have);
267       \textcolor{keyword}{delete}[]  unCompressedBuff;
268       unCompressedBuff = newUnCompressedBuff;
269       unCompressedLen = newUnCompressedLen;
270       newUnCompressedBuff = NULL;
271     \}
272   \}
273   \textcolor{keywordflow}{while} (strm.avail\_out == 0);
274 
275   \textcolor{comment}{/* clean up and return */}
276   (void)inflateEnd(&strm);
277 
278   \textcolor{keyword}{delete}[]  outBuffer;
279   outBuffer = NULL;
280 
281   \hyperlink{class_k_k_b_1_1_global_goal_keeper_a4e03a2807ca2f00c359da8625afb4cc5}{GlobalGoalKeeper::EndBlock} ();
282 
283   \textcolor{keywordflow}{return}  unCompressedBuff;
284 \textcolor{preprocessor}{#else}
285   \textcolor{keywordflow}{return} NULL;
286 \textcolor{preprocessor}{#endif}
287 \}  \textcolor{comment}{/* Decompress */}
\end{DoxyCode}
\index{K\+K\+B\+::\+Compressor@{K\+K\+B\+::\+Compressor}!Decompress@{Decompress}}
\index{Decompress@{Decompress}!K\+K\+B\+::\+Compressor@{K\+K\+B\+::\+Compressor}}
\subsubsection[{\texorpdfstring{Decompress(const void $\ast$compressed\+Buff, kkuint32 compressed\+Buff\+Len, uchar $\ast$\&un\+Compressed\+Buff, kkuint32 \&un\+Compressed\+Buff\+Size, kkuint32 \&un\+Compressed\+Buff\+Len)}{Decompress(const void *compressedBuff, kkuint32 compressedBuffLen, uchar *&unCompressedBuff, kkuint32 &unCompressedBuffSize, kkuint32 &unCompressedBuffLen)}}]{\setlength{\rightskip}{0pt plus 5cm}void Compressor\+::\+Decompress (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{compressed\+Buff, }
\item[{{\bf kkuint32}}]{compressed\+Buff\+Len, }
\item[{{\bf uchar} $\ast$\&}]{un\+Compressed\+Buff, }
\item[{{\bf kkuint32} \&}]{un\+Compressed\+Buff\+Size, }
\item[{{\bf kkuint32} \&}]{un\+Compressed\+Buff\+Len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{class_k_k_b_1_1_compressor_a9b64a1ab2887f338b1f14351c30a118e}{}\label{class_k_k_b_1_1_compressor_a9b64a1ab2887f338b1f14351c30a118e}


Definition at line 294 of file Compressor.\+cpp.


\begin{DoxyCode}
300 \{
301 \textcolor{preprocessor}{#ifdef ZLIB\_H}
302   \textcolor{keywordflow}{if}  (compressedBuff == NULL)
303     \textcolor{keywordflow}{return};
304 
305   unCompressedBuffLen = 0;
306 
307   \textcolor{comment}{//kkuint32   have      = 0;}
308 
309   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}    ret;
310   z\_stream   strm;
311 
312   \textcolor{comment}{/* allocate inflate state */}
313   strm.zalloc   = Z\_NULL;
314   strm.zfree    = Z\_NULL;
315   strm.opaque   = Z\_NULL;
316   strm.avail\_in = 0;
317   strm.next\_in  = Z\_NULL;
318 
319   ret = inflateInit (&strm);
320   \textcolor{keywordflow}{if}  (ret != Z\_OK)
321   \{
322     cerr << \textcolor{stringliteral}{"Compressor::Decompress  ***ERROR***  zlib function call 'inflateInit'  failed."} << 
      \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
323     unCompressedBuffLen = 0;
324     \textcolor{keywordflow}{return};
325   \}
326 
327   
328   \textcolor{keywordflow}{if}  (unCompressedBuff == NULL)
329   \{
330     unCompressedBuffSize = compressedBuffLen * 4;
331     unCompressedBuff = \textcolor{keyword}{new} \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}[unCompressedBuffSize];
332   \}
333 
334   strm.avail\_in = compressedBuffLen;
335   strm.next\_in  = (Bytef*)compressedBuff;  \textcolor{comment}{// Bytef = a far pointer to a unsigned char.    }
336                                            \textcolor{comment}{// Not sure if on some platforms this may cause a problem.}
337 
338   \textcolor{comment}{/* run inflate() on input until output buffer not full */}
339   \textcolor{keywordflow}{do} 
340   \{
341     \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32}  unCompressedBuffLeft = unCompressedBuffSize - unCompressedBuffLen;
342     \textcolor{keywordflow}{if}  ((strm.avail\_in * 1.2) > unCompressedBuffLeft)
343     \{
344       \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32}  increaseBy = (\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32})((strm.avail\_in * 1.2) - unCompressedBuffLeft);
345       increaseBy = \hyperlink{namespace_k_k_b_a25e187e24c091586293725f27f007ad7}{Max} (increaseBy, (\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32})10240);
346 
347       \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32}  newUncompressedBuffSize = unCompressedBuffSize + increaseBy;
348       \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  newUnCompressedBuff = \textcolor{keyword}{new} \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}[newUncompressedBuffSize];
349       memcpy (newUnCompressedBuff, unCompressedBuff, unCompressedBuffSize);
350       \textcolor{keyword}{delete}  unCompressedBuff;
351       unCompressedBuff = newUnCompressedBuff;
352       newUnCompressedBuff = NULL;
353       unCompressedBuffSize = newUncompressedBuffSize;
354     \}
355 
356     strm.avail\_out = unCompressedBuffSize - unCompressedBuffLen;
357     strm.next\_out  = (Bytef*)unCompressedBuff + unCompressedBuffLen;
358 
359     ret = inflate (&strm, Z\_NO\_FLUSH);
360     \textcolor{keywordflow}{if}  (ret == Z\_STREAM\_ERROR)
361     \{
362       cerr << \textcolor{stringliteral}{"Compressor::Decompress  ***ERROR***  zlib function call 'inflate'  failed."}  << 
      \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
363       unCompressedBuffLen = 0;
364       \textcolor{keywordflow}{return};
365     \}
366 
367     \textcolor{keywordflow}{switch} (ret) 
368     \{
369     \textcolor{keywordflow}{case} Z\_NEED\_DICT:  ret = Z\_DATA\_ERROR;     \textcolor{comment}{/* and fall through */}
370     \textcolor{keywordflow}{case} Z\_DATA\_ERROR:
371     \textcolor{keywordflow}{case} Z\_MEM\_ERROR:
372       \{
373         cerr << \textcolor{stringliteral}{"Compressor::Decompress  ***ERROR***  zlib function call 'inflate'  failed."}  << 
      \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{std::endl};
374         (void)inflateEnd (&strm);
375         unCompressedBuffLen = 0;
376         \textcolor{keywordflow}{return};
377       \}
378     \}
379 
380     unCompressedBuffLen = strm.total\_out;
381   \}
382   \textcolor{keywordflow}{while} (strm.avail\_in > 0);
383 
384   \textcolor{comment}{/* clean up and return */}
385   (void)inflateEnd(&strm);
386 
387   \textcolor{keywordflow}{return};
388 \textcolor{preprocessor}{#else}
389   \textcolor{keywordflow}{return};
390 \textcolor{preprocessor}{#endif}
391 \}  \textcolor{comment}{/* Decompress */}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/\+Kurt/\+Git\+Hub/\+K\+Square\+Libraries/\+K\+K\+Base/\hyperlink{_compressor_8h}{Compressor.\+h}\item 
C\+:/\+Users/\+Kurt/\+Git\+Hub/\+K\+Square\+Libraries/\+K\+K\+Base/\hyperlink{_compressor_8cpp}{Compressor.\+cpp}\end{DoxyCompactItemize}
