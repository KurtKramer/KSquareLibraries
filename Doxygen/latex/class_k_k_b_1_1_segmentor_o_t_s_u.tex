\hypertarget{class_k_k_b_1_1_segmentor_o_t_s_u}{}\section{K\+KB\+:\+:Segmentor\+O\+T\+SU Class Reference}
\label{class_k_k_b_1_1_segmentor_o_t_s_u}\index{K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}}


{\ttfamily \#include $<$Segmentor\+O\+T\+S\+U.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_k_k_b_1_1_segmentor_o_t_s_u_a44739a11a421c6a5696cdc0237d7d454}{Segmentor\+O\+T\+SU} (\hyperlink{class_k_k_b_1_1_run_log}{Run\+Log} \&\+\_\+log)
\item 
\hyperlink{class_k_k_b_1_1_segmentor_o_t_s_u_a07aaf4842e4839eb43bd61d5598fd498}{$\sim$\+Segmentor\+O\+T\+SU} ()
\item 
\hyperlink{class_k_k_b_1_1_pixel_value}{Pixel\+Value} \hyperlink{class_k_k_b_1_1_segmentor_o_t_s_u_a664c990335d7847a8d980d2545f99f4d}{Class\+Average\+R\+GB} (const \hyperlink{namespace_k_k_b_a80d46bd24db644a022c863bce8ae3633}{Raster\+Ptr} orig\+Image, const \hyperlink{namespace_k_k_b_a80d46bd24db644a022c863bce8ae3633}{Raster\+Ptr} segmented\+Image, \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar} segmented\+Class)
\begin{DoxyCompactList}\small\item\em Will compute the average R\+GB values of the region indicated by the segmented image. \end{DoxyCompactList}\item 
\hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar} \hyperlink{class_k_k_b_1_1_segmentor_o_t_s_u_ad78bcad3976058d44ed131fff819898e}{Get\+Class\+Closest\+To\+Target\+Color} (const \hyperlink{namespace_k_k_b_a80d46bd24db644a022c863bce8ae3633}{Raster\+Ptr} orig\+Image, const \hyperlink{namespace_k_k_b_a80d46bd24db644a022c863bce8ae3633}{Raster\+Ptr} segmented\+Image, const \hyperlink{class_k_k_b_1_1_pixel_value}{Pixel\+Value} \&target\+Color)
\begin{DoxyCompactList}\small\item\em Determines which class in the segmented image is closet in R\+GB color space to the specified target color. \end{DoxyCompactList}\item 
\hyperlink{namespace_k_k_b_a80d46bd24db644a022c863bce8ae3633}{Raster\+Ptr} \hyperlink{class_k_k_b_1_1_segmentor_o_t_s_u_af8b22e4627b37f91c5d93ec034891e7b}{Segment\+Image} (\hyperlink{namespace_k_k_b_a80d46bd24db644a022c863bce8ae3633}{Raster\+Ptr} src\+Image, \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32} num\+Classes, double \&sep)
\begin{DoxyCompactList}\small\item\em Segments image into \textquotesingle{}num\+Classes\textquotesingle{}. \end{DoxyCompactList}\item 
\hyperlink{namespace_k_k_b_a80d46bd24db644a022c863bce8ae3633}{Raster\+Ptr} \hyperlink{class_k_k_b_1_1_segmentor_o_t_s_u_affd9743f640bfb1bc88f1528bd3e8d28}{Segment\+Masked\+Image} (\hyperlink{namespace_k_k_b_a80d46bd24db644a022c863bce8ae3633}{Raster\+Ptr} src\+Image, \hyperlink{namespace_k_k_b_a80d46bd24db644a022c863bce8ae3633}{Raster\+Ptr} mask, \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32} num\+Classes, double \&sep)
\begin{DoxyCompactList}\small\item\em Segments image into \textquotesingle{}num\+Classes\textquotesingle{} taking into account only pixels indicated by \textquotesingle{}mask\textquotesingle{} image. \end{DoxyCompactList}\item 
\hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar} \hyperlink{class_k_k_b_1_1_segmentor_o_t_s_u_a84ba37425ca9e067fac8cf698729479b}{Threshold1} () const 
\item 
\hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar} \hyperlink{class_k_k_b_1_1_segmentor_o_t_s_u_a15d934ccfc4d73945877160f3c74b08b}{Threshold2} () const 
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyAuthor}{Author}
Kurt Kramer
\end{DoxyAuthor}

\begin{DoxyCode}
                                  \hyperlink{class_k_k_b_1_1_segmentor_o_t_s_u_a44739a11a421c6a5696cdc0237d7d454}{SegmentorOTSU}                                  *
                                                                                 *
Will segment an image \textcolor{keyword}{using} an implementation of OTSU. Based on MatLab code I    *
found on the Internet.  http:\textcolor{comment}{//www.biomecardio.com/matlab/otsu.html              *}
by Otsu N,                                                                       *
   <a href=\textcolor{stringliteral}{"matlab:web('http://dx.doi.org/doi:10.1109/TSMC.1979.4310076')"}>      *
   A Threshold Selection Method from Gray-Level Histograms</a>,                  *
   IEEE Trans. Syst. Man Cybern. 9:62-66;1979                                    *
\end{DoxyCode}
 \begin{DoxySeeAlso}{See also}
raster 
\end{DoxySeeAlso}


Definition at line 36 of file Segmentor\+O\+T\+S\+U.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}!Segmentor\+O\+T\+SU@{Segmentor\+O\+T\+SU}}
\index{Segmentor\+O\+T\+SU@{Segmentor\+O\+T\+SU}!K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}}
\subsubsection[{\texorpdfstring{Segmentor\+O\+T\+S\+U(\+Run\+Log \&\+\_\+log)}{SegmentorOTSU(RunLog &_log)}}]{\setlength{\rightskip}{0pt plus 5cm}Segmentor\+O\+T\+S\+U\+::\+Segmentor\+O\+T\+SU (
\begin{DoxyParamCaption}
\item[{{\bf Run\+Log} \&}]{\+\_\+log}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_segmentor_o_t_s_u_a44739a11a421c6a5696cdc0237d7d454}{}\label{class_k_k_b_1_1_segmentor_o_t_s_u_a44739a11a421c6a5696cdc0237d7d454}


Definition at line 29 of file Segmentor\+O\+T\+S\+U.\+cpp.


\begin{DoxyCode}
29                                           :
30   log        (\_log),
31   threshold1 (0),
32   threshold2 (0)
33 \{
34   \textcolor{keywordtype}{double} z = 0.0;
35   NaN = 1.0 / z;
36 \}
\end{DoxyCode}
\index{K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}!````~Segmentor\+O\+T\+SU@{$\sim$\+Segmentor\+O\+T\+SU}}
\index{````~Segmentor\+O\+T\+SU@{$\sim$\+Segmentor\+O\+T\+SU}!K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}}
\subsubsection[{\texorpdfstring{$\sim$\+Segmentor\+O\+T\+S\+U()}{~SegmentorOTSU()}}]{\setlength{\rightskip}{0pt plus 5cm}Segmentor\+O\+T\+S\+U\+::$\sim$\+Segmentor\+O\+T\+SU (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_segmentor_o_t_s_u_a07aaf4842e4839eb43bd61d5598fd498}{}\label{class_k_k_b_1_1_segmentor_o_t_s_u_a07aaf4842e4839eb43bd61d5598fd498}


Definition at line 39 of file Segmentor\+O\+T\+S\+U.\+cpp.


\begin{DoxyCode}
40 \{
41 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}!Class\+Average\+R\+GB@{Class\+Average\+R\+GB}}
\index{Class\+Average\+R\+GB@{Class\+Average\+R\+GB}!K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}}
\subsubsection[{\texorpdfstring{Class\+Average\+R\+G\+B(const Raster\+Ptr orig\+Image, const Raster\+Ptr segmented\+Image, uchar segmented\+Class)}{ClassAverageRGB(const RasterPtr origImage, const RasterPtr segmentedImage, uchar segmentedClass)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pixel\+Value} Segmentor\+O\+T\+S\+U\+::\+Class\+Average\+R\+GB (
\begin{DoxyParamCaption}
\item[{const {\bf Raster\+Ptr}}]{orig\+Image, }
\item[{const {\bf Raster\+Ptr}}]{segmented\+Image, }
\item[{{\bf uchar}}]{segmented\+Class}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_segmentor_o_t_s_u_a664c990335d7847a8d980d2545f99f4d}{}\label{class_k_k_b_1_1_segmentor_o_t_s_u_a664c990335d7847a8d980d2545f99f4d}


Will compute the average R\+GB values of the region indicated by the segmented image. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em orig\+Image} & The original image that \textquotesingle{}Segment\+Image\textquotesingle{} was performed on. \\
\hline
\mbox{\tt in}  & {\em segmented\+Image} & The segmented image that was returned by either \textquotesingle{}Segment\+Image\textquotesingle{} or \textquotesingle{}Segment\+Masked\+Image\textquotesingle{}. \\
\hline
\mbox{\tt in}  & {\em segmented\+Class} & The class in \textquotesingle{}segmented\+Image\textquotesingle{} that we want to compute average R\+GB for. \\
\hline
\end{DoxyParams}


Definition at line 1363 of file Segmentor\+O\+T\+S\+U.\+cpp.



References K\+K\+B\+::\+Raster\+::\+Blue\+Area(), K\+K\+B\+::\+Raster\+::\+Color(), K\+K\+B\+::\+Raster\+::\+Green\+Area(), K\+K\+B\+::\+Pixel\+Value\+::\+Pixel\+Value(), K\+K\+B\+::\+Raster\+::\+Red\+Area(), and K\+K\+B\+::\+Raster\+::\+Tot\+Pixels().


\begin{DoxyCode}
1367 \{
1368   \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32}  totalRed   = 0;
1369   \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32}  totalGreen = 0;
1370   \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32}  totalBlue  = 0;
1371 
1372   \textcolor{keyword}{const} \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  origRed   = origImage->\hyperlink{class_k_k_b_1_1_raster_aa3d0f9b4ce0fdd8ac97f996058d09b22}{RedArea}   ();
1373   \textcolor{keyword}{const} \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  origGreen = origImage->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
1374   \textcolor{keyword}{const} \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  origBlue  = origImage->\hyperlink{class_k_k_b_1_1_raster_ade7c77867e6b3833e96f5f86aefcffec}{BlueArea}  ();
1375 
1376   \textcolor{keyword}{const} \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  mask = segmentedImage->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
1377 
1378   \textcolor{keywordtype}{bool}  origImageColor = origImage->\hyperlink{class_k_k_b_1_1_raster_a644248f99009d64ac4b8fef4a22aff25}{Color} ();
1379 
1380   \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32}  totalPixels = (\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32})origImage->\hyperlink{class_k_k_b_1_1_raster_a174a392b71afc2295a0ccbfca3d984e9}{TotPixels} ();
1381 
1382   \textcolor{keywordflow}{for}  (\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} x = 0;  x < totalPixels;  ++x)
1383   \{
1384     \textcolor{keywordflow}{if}  (mask[x] == segmentedClass)
1385     \{
1386       totalGreen += origGreen[x];
1387       \textcolor{keywordflow}{if}  (origImageColor)
1388       \{
1389         totalRed   += origRed  [x];
1390         totalBlue  += origBlue [x];
1391       \}
1392     \}
1393   \}
1394 
1395   totalGreen = (\hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar})(0.5 + (\textcolor{keywordtype}{double})totalGreen / (double)totalPixels);
1396   \textcolor{keywordflow}{if}  (origImageColor)
1397   \{
1398     totalRed  = (\hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar})(0.5 + (\textcolor{keywordtype}{double})totalRed  / (double)totalPixels);
1399     totalBlue = (\hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar})(0.5 + (\textcolor{keywordtype}{double})totalBlue / (double)totalPixels);
1400   \}
1401 
1402   \textcolor{keywordflow}{return}  \hyperlink{class_k_k_b_1_1_pixel_value}{PixelValue} ((\hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar})totalRed, (\hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar})totalGreen, (
      \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar})totalBlue);
1403 \}  \textcolor{comment}{/* AverageRegionRGB */}
\end{DoxyCode}
\index{K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}!Get\+Class\+Closest\+To\+Target\+Color@{Get\+Class\+Closest\+To\+Target\+Color}}
\index{Get\+Class\+Closest\+To\+Target\+Color@{Get\+Class\+Closest\+To\+Target\+Color}!K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}}
\subsubsection[{\texorpdfstring{Get\+Class\+Closest\+To\+Target\+Color(const Raster\+Ptr orig\+Image, const Raster\+Ptr segmented\+Image, const Pixel\+Value \&target\+Color)}{GetClassClosestToTargetColor(const RasterPtr origImage, const RasterPtr segmentedImage, const PixelValue &targetColor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uchar} Segmentor\+O\+T\+S\+U\+::\+Get\+Class\+Closest\+To\+Target\+Color (
\begin{DoxyParamCaption}
\item[{const {\bf Raster\+Ptr}}]{orig\+Image, }
\item[{const {\bf Raster\+Ptr}}]{segmented\+Image, }
\item[{const {\bf Pixel\+Value} \&}]{target\+Color}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_segmentor_o_t_s_u_ad78bcad3976058d44ed131fff819898e}{}\label{class_k_k_b_1_1_segmentor_o_t_s_u_ad78bcad3976058d44ed131fff819898e}


Determines which class in the segmented image is closet in R\+GB color space to the specified target color. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em orig\+Image} & The original image that \textquotesingle{}Segment\+Image\textquotesingle{} was performed on. \\
\hline
\mbox{\tt in}  & {\em segmented\+Image} & The segmented image that was returned by either \textquotesingle{}Segment\+Image\textquotesingle{} or \textquotesingle{}Segment\+Masked\+Image\textquotesingle{}. \\
\hline
\mbox{\tt in}  & {\em target\+Color} & R\+GB Color that we want the chosen class to close to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The class that has the average R\+GB value closest to target\+Color. 
\end{DoxyReturn}


Definition at line 1407 of file Segmentor\+O\+T\+S\+U.\+cpp.



References K\+K\+B\+::\+Raster\+::\+Blue\+Area(), K\+K\+B\+::\+Raster\+::\+Color(), K\+K\+B\+::\+Raster\+::\+Green\+Area(), K\+K\+B\+::\+Raster\+::\+Red\+Area(), and K\+K\+B\+::\+Raster\+::\+Tot\+Pixels().


\begin{DoxyCode}
1411 \{
1412   \textcolor{comment}{// We can safely assume there will be at least 2 classes.}
1413   \hyperlink{namespace_k_k_b_ab5f0d7bc82b746e1e75e48a6394ccb60}{VectorUint32}  totalReds   (3, 0);  \textcolor{comment}{// Initialized to 3 because vectors are '0' based; index
       '0' will not be used.}
1414   \hyperlink{namespace_k_k_b_ab5f0d7bc82b746e1e75e48a6394ccb60}{VectorUint32}  totalGreens (3, 0);
1415   \hyperlink{namespace_k_k_b_ab5f0d7bc82b746e1e75e48a6394ccb60}{VectorUint32}  totalBlues  (3, 0);
1416 
1417   \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}  largestClass = 2;
1418 
1419   \textcolor{keyword}{const} \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  origRed   = origImage->\hyperlink{class_k_k_b_1_1_raster_aa3d0f9b4ce0fdd8ac97f996058d09b22}{RedArea}   ();
1420   \textcolor{keyword}{const} \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  origGreen = origImage->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
1421   \textcolor{keyword}{const} \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  origBlue  = origImage->\hyperlink{class_k_k_b_1_1_raster_ade7c77867e6b3833e96f5f86aefcffec}{BlueArea}  ();
1422 
1423   \textcolor{keyword}{const} \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  mask = segmentedImage->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
1424 
1425   \textcolor{keywordtype}{bool}  origImageColor = origImage->\hyperlink{class_k_k_b_1_1_raster_a644248f99009d64ac4b8fef4a22aff25}{Color} ();
1426 
1427   \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32}  totalPixels = (\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32})origImage->\hyperlink{class_k_k_b_1_1_raster_a174a392b71afc2295a0ccbfca3d984e9}{TotPixels} ();
1428 
1429   \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}  classValue = 0;
1430 
1431   \textcolor{keywordflow}{for}  (\hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32} x = 0;  x < totalPixels;  ++x)
1432   \{
1433     classValue = mask[x];
1434     \textcolor{keywordflow}{while} (classValue > largestClass)
1435     \{
1436       totalReds.push\_back   (0);
1437       totalGreens.push\_back (0);
1438       totalBlues.push\_back  (0);
1439       ++largestClass;
1440     \}
1441 
1442     totalGreens[classValue] += origGreen[x];
1443     \textcolor{keywordflow}{if}  (origImageColor)
1444     \{
1445       totalReds[classValue]  += origRed [x];
1446       totalBlues[classValue] += origBlue[x];
1447     \}
1448   \}
1449 
1450   \hyperlink{namespace_k_k_b_a4820c3670ee1fe74f0c4de981c600faf}{VectorFloat} distFromTarget (largestClass + 1, 0.0f);
1451 
1452   \textcolor{keywordtype}{double}  closestDistFound = 99999999.99;
1453   \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}   closestClass = 255;
1454 
1455   \textcolor{keywordflow}{for}  (\hyperlink{namespace_k_k_b_ab8557ae1b1f2361659d82a890e2f8014}{uint} x = 1;  x <= largestClass;  ++x)
1456   \{
1457     \textcolor{keywordtype}{double} avgRed   = (double)totalReds  [x] / (\textcolor{keywordtype}{double})totalPixels;
1458     \textcolor{keywordtype}{double} avgGreen = (double)totalGreens[x] / (\textcolor{keywordtype}{double})totalPixels;
1459     \textcolor{keywordtype}{double} avgBlue  = (double)totalBlues [x] / (\textcolor{keywordtype}{double})totalPixels;
1460 
1461     \textcolor{keywordtype}{double}  deltaRed   = fabs (targetColor.\hyperlink{class_k_k_b_1_1_pixel_value_a734e16b4afd9a270df67aa1ce726e2d0}{r} - avgRed);
1462     \textcolor{keywordtype}{double}  deltaGreen = fabs (targetColor.\hyperlink{class_k_k_b_1_1_pixel_value_ab9b7056f3cf6f67a5987a8119ceaab67}{g} - avgGreen);
1463     \textcolor{keywordtype}{double}  deltaBlue  = fabs (targetColor.\hyperlink{class_k_k_b_1_1_pixel_value_ac43e49760f71b756dba6c40e80e7917a}{b} - avgBlue);
1464     \textcolor{keywordtype}{double}  distToTarget = sqrt (deltaRed * deltaRed + deltaGreen * deltaGreen + deltaBlue * deltaBlue);
1465 
1466     \textcolor{keywordflow}{if}  (distToTarget < closestDistFound)
1467     \{
1468       closestDistFound = distToTarget;
1469       closestClass = x;
1470     \}
1471   \}
1472 
1473   \textcolor{keywordflow}{return}  closestClass;
1474 \}  \textcolor{comment}{/* GetClassClosestToTargetColor */}
\end{DoxyCode}
\index{K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}!Segment\+Image@{Segment\+Image}}
\index{Segment\+Image@{Segment\+Image}!K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}}
\subsubsection[{\texorpdfstring{Segment\+Image(\+Raster\+Ptr src\+Image, kkint32 num\+Classes, double \&sep)}{SegmentImage(RasterPtr srcImage, kkint32 numClasses, double &sep)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Raster\+Ptr} Segmentor\+O\+T\+S\+U\+::\+Segment\+Image (
\begin{DoxyParamCaption}
\item[{{\bf Raster\+Ptr}}]{src\+Image, }
\item[{{\bf kkint32}}]{num\+Classes, }
\item[{double \&}]{sep}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_segmentor_o_t_s_u_af8b22e4627b37f91c5d93ec034891e7b}{}\label{class_k_k_b_1_1_segmentor_o_t_s_u_af8b22e4627b37f91c5d93ec034891e7b}


Segments image into \textquotesingle{}num\+Classes\textquotesingle{}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em src\+Image} & Image to segment. If it is a color image will be converted to Gray-\/\+Scale using \textquotesingle{}Create\+Gray\+Scale\+K\+L\+T\+On\+Masked\+Area\textquotesingle{} \\
\hline
\mbox{\tt in}  & {\em num\+Classes} & Number of classes to segment image into. Current only \textquotesingle{}2\textquotesingle{} and \textquotesingle{}3\textquotesingle{} are supported. \\
\hline
\mbox{\tt out}  & {\em sep} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Labeled gray-\/scale image where pixels will be labels into their respective class; between \textquotesingle{}1\textquotesingle{} and \textquotesingle{}num\+Classes\textquotesingle{}. 
\end{DoxyReturn}


Definition at line 690 of file Segmentor\+O\+T\+S\+U.\+cpp.



References K\+K\+B\+::\+Raster\+::\+Color(), K\+K\+B\+::\+Raster\+::\+Create\+Gray\+Scale\+K\+L\+T(), K\+K\+B\+::\+Matrix\+::\+Find\+Max\+Value(), K\+K\+B\+::\+Raster\+::\+Green\+Area(), K\+K\+B\+::\+Raster\+::\+Height(), K\+K\+B\+::\+Matrix\+::operator+(), K\+K\+B\+::\+Matrix\+::operator-\/(), K\+K\+B\+::operator-\/(), K\+K\+B\+::\+Raster\+::\+Raster(), K\+K\+B\+::\+Raster\+::\+Tot\+Pixels(), and K\+K\+B\+::\+Raster\+::\+Width().


\begin{DoxyCode}
694 \{
695   \textcolor{comment}{/*}
696 \textcolor{comment}{  function [IDX,sep] = otsu (srcImage, numClasses)}
697 \textcolor{comment}{}
698 \textcolor{comment}{  %OTSU Global image thresholding/segmentation using Otsu's method.}
699 \textcolor{comment}{  %   IDX = OTSU(srcImage,N) segments the image srcImage into N classes by means of Otsu's}
700 \textcolor{comment}{  %   N-thresholding method. OTSU returns an array IDX containing the cluster}
701 \textcolor{comment}{  %   indexes (from 1 to N) of each point. Zero values are assigned to}
702 \textcolor{comment}{  %   non-finite (NaN or Inf) pixels.}
703 \textcolor{comment}{  %}
704 \textcolor{comment}{  %   IDX = OTSU(srcImage) uses two classes (N=2, default value).}
705 \textcolor{comment}{  %}
706 \textcolor{comment}{  %   [IDX,sep] = OTSU(...) also returns the value (sep) of the separability}
707 \textcolor{comment}{  %   criterion within the range [0 1]. Zero is obtained only with data}
708 \textcolor{comment}{  %   having less than N values, whereas one (optimal value) is obtained only}
709 \textcolor{comment}{  %   with N-valued arrays.}
710 \textcolor{comment}{  %}
711 \textcolor{comment}{  %   Notes:}
712 \textcolor{comment}{  %   -----}
713 \textcolor{comment}{  %   It should be noticed that the thresholds generally become less credible}
714 \textcolor{comment}{  %   as the number of classes (N) to be separated increases (see Otsu's}
715 \textcolor{comment}{  %   paper for more details).}
716 \textcolor{comment}{  %}
717 \textcolor{comment}{  %   If srcImage is an RGB image, a Karhunen-Loeve transform is first performed on}
718 \textcolor{comment}{  %   the three R,G,B channels. The segmentation is then carried out on the}
719 \textcolor{comment}{  %   image component that contains most of the energy. }
720 \textcolor{comment}{  %}
721 \textcolor{comment}{  %   Example:}
722 \textcolor{comment}{  %   -------}
723 \textcolor{comment}{  %   load clown}
724 \textcolor{comment}{  %   subplot(221)}
725 \textcolor{comment}{  %   X = ind2rgb(X,map);}
726 \textcolor{comment}{  %   imshow(X)}
727 \textcolor{comment}{  %   title('Original','FontWeight','bold')}
728 \textcolor{comment}{  %   for numClasses = 2:4}
729 \textcolor{comment}{  %     IDX = otsu(X,numClasses);}
730 \textcolor{comment}{  %     subplot(2,2,numClasses)}
731 \textcolor{comment}{  %     imagesc(IDX), axis image off}
732 \textcolor{comment}{  %     title(['numClasses = ' int2str(numClasses)],'FontWeight','bold')}
733 \textcolor{comment}{  %   end}
734 \textcolor{comment}{  %   colormap(gray)}
735 \textcolor{comment}{  %}
736 \textcolor{comment}{  %   Reference:}
737 \textcolor{comment}{  %   ---------}
738 \textcolor{comment}{  %   Otsu N, <a href="matlab:web('http://dx.doi.org/doi:10.1109/TSMC.1979.4310076')">A Threshold Selection
       Method from Gray-Level Histograms</a>,}
739 \textcolor{comment}{  %   IEEE Trans. Syst. Man Cybern. 9:62-66;1979 }
740 \textcolor{comment}{  %}
741 \textcolor{comment}{  %   See also GRAYTHRESH, IM2BW}
742 \textcolor{comment}{  %}
743 \textcolor{comment}{  %   -- Damien Garcia -- 2007/08, revised 2010/03}
744 \textcolor{comment}{  %   Visit my <a}
745 \textcolor{comment}{  %   href="matlab:web('http://www.biomecardio.com/matlab/otsu.html')">website</a> for more details about
       OTSU}
746 \textcolor{comment}{  */}
747   
748   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  pixelIdx = 0;
749   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  x        = 0;
750   \textcolor{keywordtype}{bool}  isColorImage = srcImage->\hyperlink{class_k_k_b_1_1_raster_a644248f99009d64ac4b8fef4a22aff25}{Color} ();
751 
752   \textcolor{comment}{//  Checking numClasses (number of classes)}
753   
754   \textcolor{keywordflow}{if}  (numClasses == 1)
755   \{
756     \textcolor{comment}{//IDX = NaN(size(srcImage));}
757     \textcolor{comment}{//sep = 0;}
758     \textcolor{keywordflow}{return}  NULL;
759   \}
760 
761   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}  ((numClasses < 1)  ||  (numClasses > 255))
762   \{
763     log.\hyperlink{class_k_k_b_1_1_run_log_a32cf761d7f2e747465fd80533fdbb659}{Level} (-1) << \textcolor{stringliteral}{"SegmentorOTSU::SegmentImage  ***ERROR***   'numClasses must be a between 1 and
       255 !'"} << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl};
764     sep = 0;
765     \textcolor{keywordflow}{return} NULL;
766   \}
767 
768   \textcolor{keywordflow}{if}  (isColorImage)
769   \{
770     srcImage = srcImage->\hyperlink{class_k_k_b_1_1_raster_afc5e92625a20de51791bd369340d9fa2}{CreateGrayScaleKLT} ();
771   \}
772   \textcolor{keywordflow}{else}
773   \{
774     srcImage = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_raster}{Raster} (*srcImage);
775   \}
776 
777   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  totPixels = srcImage->\hyperlink{class_k_k_b_1_1_raster_a174a392b71afc2295a0ccbfca3d984e9}{TotPixels} ();
778   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  pixelsCounted = 0;
779   \hyperlink{namespace_k_k_b_a791ebe73f89917067a7aab9dbd817e45}{VectorInt}  unI;
780   \hyperlink{namespace_k_k_b_a791ebe73f89917067a7aab9dbd817e45}{VectorInt}  unICounts;
781   \hyperlink{namespace_k_k_b_adf8a10085d231870d8a072046d6cba10}{VectorInt32}  counts (256, 0);
782   \{
783     \textcolor{comment}{// %% Convert to 256 levels}
784     \textcolor{comment}{// srcImage = srcImage-min(srcImage(:));}
785     \textcolor{comment}{// srcImage = round(srcImage/max(srcImage(:))*255);}
786     \textcolor{comment}{//  Re-scale Source Image to utilize range of 0 through 255.}
787 
788     \textcolor{comment}{//%% Probability dCistribution}
789     \textcolor{comment}{//unI = sort(unique(srcImage));}
790     \textcolor{comment}{//nbins = min(length(unI),256);}
791  
792 
793     \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  greenArea = srcImage->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
794 
795     \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}  pixelMin = 255;
796     \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}  pixelMax = 1;
797 
798     \textcolor{keywordflow}{for}  (pixelIdx = 1;  pixelIdx < totPixels;  ++pixelIdx)
799     \{
800       \textcolor{keywordflow}{if}  (greenArea[pixelIdx] < 1)
801         \textcolor{keywordflow}{continue};
802 
803       pixelsCounted++;
804 
805       \textcolor{keywordflow}{if}  (greenArea[pixelIdx] < pixelMin)
806         pixelMin = greenArea[pixelIdx];
807 
808       \textcolor{keywordflow}{if}  (greenArea[pixelIdx] > pixelMax)
809         pixelMax = greenArea[pixelIdx];
810     \}
811 
812     \hyperlink{namespace_k_k_b_a791ebe73f89917067a7aab9dbd817e45}{VectorInt}  counts (256, 0);
813 
814     \textcolor{keywordflow}{for}  (pixelIdx = 0;  pixelIdx < totPixels;  ++pixelIdx)
815     \{
816       \textcolor{comment}{/*}
817 \textcolor{comment}{      double  pixelFraction = (double)((double)(greenArea[pixelIdx]) - pixelMin) / (double)srcRange;}
818 \textcolor{comment}{      kkuint32  newPixelVal = (uchar)(pixelFraction * 256.0 + 0.5);}
819 \textcolor{comment}{      if  (newPixelVal > 255)}
820 \textcolor{comment}{        newPixelVal = 255;}
821 \textcolor{comment}{}
822 \textcolor{comment}{      greenArea[pixelIdx] = (uchar)newPixelVal;}
823 \textcolor{comment}{      counts[newPixelVal]++;}
824 \textcolor{comment}{      */}
825       counts[greenArea[pixelIdx]]++;
826     \}
827 
828     \textcolor{keywordflow}{for}  (x = 1;  x < (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})counts.size ();  ++x)
829     \{
830       \textcolor{keywordflow}{if}  (counts[x] > 0)
831       \{
832         unI.push\_back (x);
833         unICounts.push\_back (counts[x]);
834       \}
835     \}
836   \}
837 
838   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  nbins = (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})unI.size ();
839 
840   \textcolor{keywordflow}{if}  (nbins <= numClasses)
841   \{
842     \textcolor{comment}{// IDX = ones (size(srcImage));}
843     \textcolor{comment}{//for i = 1:numClasses, IDX(srcImage==unI(i)) = i; end}
844     \textcolor{comment}{//sep = 1;}
845     \hyperlink{class_k_k_b_1_1_raster}{RasterPtr}  result = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_raster}{Raster} (srcImage->\hyperlink{class_k_k_b_1_1_raster_af8d10d15697d5b92fb9595c48b529feb}{Height} (), srcImage->
      \hyperlink{class_k_k_b_1_1_raster_aa2780c0b7ae75b7b595f99329689c1f6}{Width} (), \textcolor{keyword}{false});
846     \textcolor{keywordflow}{for}  (x = 0;  x < nbins;  ++x)
847     \{
848       LabelRaster (result, unI[x], x, srcImage);
849     \}
850     sep = 1;
851     \textcolor{keyword}{delete}  srcImage;   
852     srcImage = NULL;
853     \textcolor{keywordflow}{return}  result;
854   \}
855 
856   \textcolor{comment}{//elseif  (nbins < 256)}
857   \textcolor{comment}{//  [histo,pixval] = hist(srcImage(:),unI);}
858   \textcolor{comment}{//else}
859   \textcolor{comment}{//  [histo,pixval] = hist(srcImage(:),256);}
860   \hyperlink{namespace_k_k_b_a791ebe73f89917067a7aab9dbd817e45}{VectorInt}  histo  = unICounts;
861   \hyperlink{namespace_k_k_b_a791ebe73f89917067a7aab9dbd817e45}{VectorInt}  pixval = unI;
862 
863   \textcolor{comment}{//P = histo/sum(histo);}
864   \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  P (histo.size (), 0.0);
865   \textcolor{keywordflow}{for}  (x = 0;  x < (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})histo.size ();  ++x)
866     P[x] = (\textcolor{keywordtype}{double})(histo[x]) / (\textcolor{keywordtype}{double})pixelsCounted;
867 
868   \textcolor{comment}{//clear unI}
869   unI.clear ();
870 
871   \textcolor{comment}{//%% Zeroth- and first-order cumulative moments}
872   \textcolor{comment}{//w = cumsum(P);}
873   \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  w (P.size (), 0.0);
874   w[0] = P[0];
875   \textcolor{keywordflow}{for}  (x = 1;  x < (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})P.size (); ++x)
876     w[x] = w[x - 1] + P[x];
877 
878   \textcolor{comment}{//mu = cumsum((1:nbins).*P);}
879   \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  mu (P.size (), 0.0);
880   mu[0] = 1.0 * P[0];
881   \textcolor{keywordflow}{for}  (x = 1;  x < (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})P.size ();  ++x)
882     mu[x] = mu[x - 1] + ((x + 1) * P[x]);
883   \textcolor{keywordtype}{double}  muEnd = mu[mu.size () - 1];
884   
885   \textcolor{comment}{//%% Maximal sigmaB^2 and Segmented image}
886   \textcolor{keywordflow}{if}  (numClasses == 2)
887   \{
888     \textcolor{comment}{//sigma2B =...}
889     \textcolor{comment}{//    (mu(end) * w(2:end-1) - mu(2:end-1)) .^2  ./  w(2:end-1)./(1-w(2:end-1));}
890     \textcolor{comment}{//    ------------------- P1 -----------------      ----------- P2 -----------}
891     \textcolor{comment}{//[maxsig,k] = max(sigma2B);}
892 
893     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  wSubSet  = SubSet (w,  1, (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})w.size  () - 2);
894     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  muSubSet = SubSet (mu, 1, (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})mu.size () - 2);
895    
896     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble} P1 = Power (Subt (muEnd * wSubSet, muSubSet), 2.0);
897     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble} P2 = DotDiv (wSubSet, Subt (1.0, wSubSet));
898     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble} sigma2B = DotDiv (P1, P2);
899     \textcolor{keywordtype}{double}  maxSig = sigma2B[0];
900     \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32} maxSigIdx = 0;
901     \textcolor{keywordflow}{for}  (x = 1;  x < (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})sigma2B.size ();  ++x)
902     \{
903       \textcolor{keywordflow}{if}  (sigma2B[x] > maxSig)
904       \{
905         maxSig = sigma2B[x];
906         maxSigIdx = x;
907       \}
908     \}
909       
910     \textcolor{comment}{//[maxsig,k] = max(sigma2B);}
911     \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  k = maxSigIdx;
912     
913     \textcolor{comment}{//% segmented image}
914     \textcolor{comment}{//IDX = ones(size(srcImage));}
915     \textcolor{comment}{//IDX(srcImage>pixval(k+1)) = 2;}
916     threshold1 = pixval[k + 1];
917     \hyperlink{class_k_k_b_1_1_raster}{RasterPtr}  result = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_raster}{Raster} (srcImage->\hyperlink{class_k_k_b_1_1_raster_af8d10d15697d5b92fb9595c48b529feb}{Height} (), srcImage->
      \hyperlink{class_k_k_b_1_1_raster_aa2780c0b7ae75b7b595f99329689c1f6}{Width} (), \textcolor{keyword}{false});
918     \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  resultArea = result->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
919     \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  srcArea    = srcImage->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
920 
921     \textcolor{keywordflow}{while}  (\textcolor{keyword}{true})
922     \{
923       \hyperlink{namespace_k_k_b_af8d832f05c54994a1cce25bd5743e19a}{kkuint32}  numClass2Pixs = 0;
924       \textcolor{keywordflow}{for}  (x = 0;  x < totPixels;  ++x)
925       \{
926         \textcolor{keywordflow}{if}  (srcArea[x] > threshold1)
927         \{
928           resultArea[x] = 2;
929           ++numClass2Pixs;
930         \}
931         \textcolor{keywordflow}{else}
932         \{
933           resultArea[x] = 1;
934         \}
935       \}
936 
937       \textcolor{keywordflow}{if}  ((threshold1 < 1)  ||  (numClass2Pixs >100))
938         \textcolor{keywordflow}{break};
939       --threshold1;
940     \}
941     
942     \textcolor{comment}{//% separability criterion}
943     \textcolor{comment}{//sep = maxsig/sum(((1:nbins)-mu(end)).^2.*P);}
944     \textcolor{keywordtype}{double}  sum = 0.0;
945     \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  y = 0;
946     muEnd = mu[mu.size () - 1];
947     \textcolor{keywordflow}{for}  (x = 0, y = 1;  x < nbins;  ++x, ++y)
948       sum = pow (((\textcolor{keywordtype}{double})y - muEnd), 2.0) * P[x];
949 
950     sep = maxSig / sum;
951     \textcolor{keyword}{delete}  srcImage;
952     srcImage = NULL;
953     \textcolor{keywordflow}{return}  result;
954   \}
955     
956   \textcolor{keywordflow}{if}  (numClasses == 3)
957   \{
958     \textcolor{comment}{//w0 = w;}
959     \textcolor{comment}{//w2 = fliplr(cumsum(fliplr(P)));}
960     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  w0 = w;
961     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  w2 = FlipLeftRight (CumSum (FlipLeftRight (P)));
962 
963 
964     \textcolor{comment}{//[w0,w2] = ndgrid(w0,w2);}
965     \hyperlink{class_k_k_b_1_1_matrix}{Matrix} w0M ((\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})w0.size (), (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})w0.size ());
966     \hyperlink{class_k_k_b_1_1_matrix}{Matrix} w2M ((\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})w2.size (), (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})w2.size ());
967     NdGrid (w0, w2, w0M, w2M);
968 
969     
970     \textcolor{comment}{//mu0 = mu./w;}
971     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  mu0 = DotDiv (mu, w);
972 
973     \textcolor{comment}{//mu2 = fliplr(cumsum(fliplr((1:nbins).*P)) ./ cumsum(fliplr(P)));}
974     \textcolor{comment}{//            1      2      34       4   32        3      4 321}
975     \textcolor{comment}{//             ---------- P1 -------------     ------ P2 --------}
976     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  P1 = CumSum (FlipLeftRight (DotMult (BDV (1.0, 1.0, (\textcolor{keywordtype}{double})nbins), P)));
977     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  P2 = CumSum (FlipLeftRight (P));
978     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  mu2 = FlipLeftRight (DotDiv (P1, P2));
979 
980     \textcolor{comment}{// TODO  }
981     \textcolor{comment}{//[mu0,mu2] = ndgrid(mu0,mu2);}
982     \hyperlink{class_k_k_b_1_1_matrix}{Matrix}  mu0M ((\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})mu0.size (), (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})mu0.size ());
983     \hyperlink{class_k_k_b_1_1_matrix}{Matrix}  mu2M ((\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})mu2.size (), (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})mu2.size ());
984     NdGrid (mu0, mu2, mu0M, mu2M);
985     
986     \textcolor{comment}{//w1 = 1-w0-w2;}
987     \hyperlink{class_k_k_b_1_1_matrix}{Matrix}  w1M = 1.0 - w0M - w2M;
988 
989     \textcolor{comment}{//w1(w1<=0) = NaN;}
990     MakeNanWhenLesOrEqualZero (w1M);
991 
992     \textcolor{comment}{//sigma2B =...}
993     \textcolor{comment}{//    w0.*(mu0-mu(end)).^2 + w2.*(mu2-mu(end)).^2 +...}
994     \textcolor{comment}{//    (w0.*(mu0-mu(end)) + w2.*(mu2-mu(end))).^2./w1;}
995     \hyperlink{class_k_k_b_1_1_matrix}{Matrix}  P1M = (DotMult (w0M, Power ((mu0M - muEnd), 2.0)))  +  (DotMult (w2M, Power ((mu2M - 
      muEnd), 2.0)));
996     \hyperlink{class_k_k_b_1_1_matrix}{Matrix}  P2M = DotDiv (Power ((DotMult (w0M, (mu0M - muEnd)) + DotMult (w2M, (mu2M - muEnd))), 2.0
      ), w1M);
997     \hyperlink{class_k_k_b_1_1_matrix}{Matrix}  sigma2B = P1M + P2M;
998 
999 
1000     \textcolor{comment}{//sigma2B(isnan(sigma2B)) = 0; % zeroing if k1 >= k2}
1001     ZeroOutNaN (sigma2B);
1002 
1003     \textcolor{comment}{//[maxsig,k] = max(sigma2B(:));         % Turns sigma2B into 1D Array then locates largest value and
       index.}
1004     \textcolor{comment}{// [k1,k2] = ind2sub([nbins nbins],k);  % Sets k1 and k2 to the indexes for k mapped into a 2D square
       matrix that is (nbins x nbins)}
1005     \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  k1, k2;
1006     \textcolor{keywordtype}{double}  maxsig = 0.0;
1007     sigma2B.\hyperlink{class_k_k_b_1_1_matrix_ac4861e80e5f5f5a03bc61fd756538af5}{FindMaxValue} (maxsig, k1, k2);
1008    
1009     \textcolor{comment}{//% segmented image}
1010     \hyperlink{class_k_k_b_1_1_raster}{RasterPtr}  result = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_raster}{Raster} (srcImage->\hyperlink{class_k_k_b_1_1_raster_af8d10d15697d5b92fb9595c48b529feb}{Height} (), srcImage->
      \hyperlink{class_k_k_b_1_1_raster_aa2780c0b7ae75b7b595f99329689c1f6}{Width} (), \textcolor{keyword}{false});
1011     \{
1012       \textcolor{comment}{//IDX = ones(size(srcImage))*3;}
1013       \textcolor{comment}{//IDX(srcImage<=pixval(k1)) = 1;}
1014       \textcolor{comment}{//IDX(srcImage>pixval(k1) & srcImage<=pixval(k2)) = 2;}
1015       \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  srcData = srcImage->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
1016       \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  data = result->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
1017       threshold1 = pixval[k1];
1018       threshold2 = pixval[k2];
1019       \textcolor{keywordflow}{for}  (x = 0;  x < totPixels;  ++x)
1020       \{
1021         \textcolor{keywordflow}{if}  (srcData[x] <= threshold1)
1022           data[x] = 1;
1023         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}  (srcData[x] <= threshold2)
1024           data[x] = 2;
1025         \textcolor{keywordflow}{else}
1026           data[x] = 3;
1027       \}
1028     \}
1029     
1030     \textcolor{comment}{//% separability criterion}
1031     \textcolor{comment}{//sep = maxsig / sum (((1:nbins)-mu(end)).^2.*P);}
1032 
1033     \textcolor{comment}{//VectorDouble  xxx = BDV (1.0, 1.0, (double)nbins);}
1034     \textcolor{comment}{//VectorDouble  yyy = Subt (xxx, muEnd);}
1035     \textcolor{comment}{//VectorDouble  zzz = Power (yyy, 2.0);}
1036     sep = maxsig / Sum (DotMult (Power (Subt (BDV (1.0, 1.0, (\textcolor{keywordtype}{double})nbins), muEnd), 2.0), P));
1037     \textcolor{keyword}{delete}  srcImage;
1038     srcImage = NULL;
1039     \textcolor{keywordflow}{return}  result;
1040   \}
1041     
1042   \{
1043     \textcolor{comment}{/*}
1044 \textcolor{comment}{    //k0 = linspace(0,1,numClasses+1);   %  k0 = row vector of linear spaced points between 0 and 1  with
       (numClasses + 1) points}
1045 \textcolor{comment}{    VectorDouble  k0 = LinSpace (0, 1, numClasses + 1);}
1046 \textcolor{comment}{}
1047 \textcolor{comment}{    //k0 = k0(2:numClasses);}
1048 \textcolor{comment}{    }
1049 \textcolor{comment}{}
1050 \textcolor{comment}{    [k,y] = fminsearch(@sig\_func,k0,optimset('TolX',1));}
1051 \textcolor{comment}{    k = round(k*(nbins-1)+1);}
1052 \textcolor{comment}{    }
1053 \textcolor{comment}{    % segmented image}
1054 \textcolor{comment}{    IDX = ones(size(srcImage))*numClasses;}
1055 \textcolor{comment}{    IDX(srcImage<=pixval(k(1))) = 1;}
1056 \textcolor{comment}{    for i = 1:numClasses-2}
1057 \textcolor{comment}{        IDX(srcImage>pixval(k(i)) & srcImage<=pixval(k(i+1))) = i+1;}
1058 \textcolor{comment}{    end}
1059 \textcolor{comment}{    }
1060 \textcolor{comment}{    % separability criterion}
1061 \textcolor{comment}{    sep = 1-y;}
1062 \textcolor{comment}{    */}
1063   \}
1064 
1065   \textcolor{keyword}{delete}  srcImage;
1066   srcImage = NULL;
1067     
1068   \textcolor{keywordflow}{return} NULL;
1069 \}  \textcolor{comment}{/* SegmentImage */}
\end{DoxyCode}
\index{K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}!Segment\+Masked\+Image@{Segment\+Masked\+Image}}
\index{Segment\+Masked\+Image@{Segment\+Masked\+Image}!K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}}
\subsubsection[{\texorpdfstring{Segment\+Masked\+Image(\+Raster\+Ptr src\+Image, Raster\+Ptr mask, kkint32 num\+Classes, double \&sep)}{SegmentMaskedImage(RasterPtr srcImage, RasterPtr mask, kkint32 numClasses, double &sep)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Raster\+Ptr} Segmentor\+O\+T\+S\+U\+::\+Segment\+Masked\+Image (
\begin{DoxyParamCaption}
\item[{{\bf Raster\+Ptr}}]{src\+Image, }
\item[{{\bf Raster\+Ptr}}]{mask, }
\item[{{\bf kkint32}}]{num\+Classes, }
\item[{double \&}]{sep}
\end{DoxyParamCaption}
)}\hypertarget{class_k_k_b_1_1_segmentor_o_t_s_u_affd9743f640bfb1bc88f1528bd3e8d28}{}\label{class_k_k_b_1_1_segmentor_o_t_s_u_affd9743f640bfb1bc88f1528bd3e8d28}


Segments image into \textquotesingle{}num\+Classes\textquotesingle{} taking into account only pixels indicated by \textquotesingle{}mask\textquotesingle{} image. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em src\+Image} & Image to segment. If it is a color image will be converted to Gray-\/\+Scale using \textquotesingle{}Create\+Gray\+Scale\+K\+L\+T\+On\+Masked\+Area\textquotesingle{} \\
\hline
\mbox{\tt in}  & {\em mask} & Indicates which pixels to consider when thresholding image. Pixels that are not part of mask will be assigned label \textquotesingle{}0\textquotesingle{}. \\
\hline
\mbox{\tt in}  & {\em num\+Classes} & Number of classes to segment image into. Current only \textquotesingle{}2\textquotesingle{} and \textquotesingle{}3\textquotesingle{} are supported. \\
\hline
\mbox{\tt out}  & {\em sep} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Labeled gray-\/scale image where pixels will be label into their respective class; between \textquotesingle{}1\textquotesingle{} and \textquotesingle{}num\+Classes\textquotesingle{}.
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em src\+Image} & Image to segment. If it is a color image will be converted to Gray\+Scale using \textquotesingle{}Create\+Gray\+Scale\+K\+L\+T\+On\+Masked\+Area\textquotesingle{} \\
\hline
\mbox{\tt in}  & {\em mask} & Indicates which pixels to consider when thresholding image. Pixels that are not part of mask will be assigned label \textquotesingle{}0\textquotesingle{}. \\
\hline
\mbox{\tt in}  & {\em num\+Classes} & Number of classes to segment image into. Current only \textquotesingle{}2\textquotesingle{} and \textquotesingle{}3\textquotesingle{} are supported. \\
\hline
\mbox{\tt out}  & {\em sep} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Labeled Gray\+Scale image where pixels will be label into their respective class; between \textquotesingle{}1\textquotesingle{} and \textquotesingle{}num\+Classes\textquotesingle{}. 
\end{DoxyReturn}


Definition at line 1085 of file Segmentor\+O\+T\+S\+U.\+cpp.



References K\+K\+B\+::\+Raster\+::\+Background\+Pixel\+T\+H(), K\+K\+B\+::\+Raster\+::\+Color(), K\+K\+B\+::\+Raster\+::\+Create\+Gray\+Scale\+K\+L\+T(), K\+K\+B\+::\+Raster\+::\+Create\+Gray\+Scale\+K\+L\+T\+On\+Masked\+Area(), K\+K\+B\+::\+Matrix\+::\+Find\+Max\+Value(), K\+K\+B\+::\+Raster\+::\+Green\+Area(), K\+K\+B\+::\+Raster\+::\+Height(), K\+K\+B\+::\+Matrix\+::operator+(), K\+K\+B\+::\+Matrix\+::operator-\/(), K\+K\+B\+::operator-\/(), K\+K\+B\+::\+Raster\+::\+Raster(), K\+K\+B\+::\+Raster\+::\+Total\+Background\+Pixels(), K\+K\+B\+::\+Raster\+::\+Tot\+Pixels(), and K\+K\+B\+::\+Raster\+::\+Width().


\begin{DoxyCode}
1090 \{
1091   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  pixelIdx = 0;
1092   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  x        = 0;
1093   \textcolor{keywordtype}{bool}  isColorImage = srcImage->\hyperlink{class_k_k_b_1_1_raster_a644248f99009d64ac4b8fef4a22aff25}{Color} ();
1094 
1095   \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  maskArea = NULL;
1096   \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}   maskTh   = 0;
1097   \textcolor{keywordflow}{if}  (mask)
1098   \{
1099     maskArea = mask->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
1100     maskTh   = mask->\hyperlink{class_k_k_b_1_1_raster_a96e0ed160e633c316cf83890ef3438eb}{BackgroundPixelTH} ();
1101   \}
1102 
1103   \textcolor{keywordflow}{if}  (numClasses == 1)
1104   \{
1105     \textcolor{keywordflow}{return}  NULL;
1106   \}
1107 
1108   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}  ((numClasses < 1)  ||  (numClasses > 255))
1109   \{
1110     log.\hyperlink{class_k_k_b_1_1_run_log_a32cf761d7f2e747465fd80533fdbb659}{Level} (-1) << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl} << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl}
1111       << \textcolor{stringliteral}{"SegmentorOTSU::SegmentMaskedImage  ***ERROR***   'numClasses must be a between 1 and 255 !'"} << 
      \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl}
1112       << \hyperlink{namespace_k_k_b_ad1f50f65af6adc8fa9e6f62d007818a8}{endl};
1113     sep = 0;
1114     \textcolor{keywordflow}{return} NULL;
1115   \}
1116 
1117   \textcolor{keywordflow}{if}  (isColorImage)
1118   \{
1119     \textcolor{keywordflow}{if}  (mask)
1120       srcImage = srcImage->\hyperlink{class_k_k_b_1_1_raster_a279dc0c8311fd9b4cfaf351ae515bba2}{CreateGrayScaleKLTOnMaskedArea} (*mask);
1121     \textcolor{keywordflow}{else}
1122       srcImage = srcImage->\hyperlink{class_k_k_b_1_1_raster_afc5e92625a20de51791bd369340d9fa2}{CreateGrayScaleKLT} ();
1123   \}
1124   \textcolor{keywordflow}{else}
1125   \{
1126     srcImage = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_raster}{Raster} (*srcImage);
1127   \}
1128 
1129   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  totPixels = srcImage->\hyperlink{class_k_k_b_1_1_raster_a174a392b71afc2295a0ccbfca3d984e9}{TotPixels} ();
1130   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  totMaskPixels = totPixels;
1131   \textcolor{keywordflow}{if}  (mask)
1132     totMaskPixels = mask->\hyperlink{class_k_k_b_1_1_raster_ac227e0f97820f74b2518b10852fd2d13}{TotalBackgroundPixels} ();
1133 
1134   \hyperlink{namespace_k_k_b_a791ebe73f89917067a7aab9dbd817e45}{VectorInt}  unI;
1135   \hyperlink{namespace_k_k_b_a791ebe73f89917067a7aab9dbd817e45}{VectorInt}  unICounts;
1136   
1137   \{
1138     \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  greenArea = srcImage->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
1139 
1140     \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}  pixelMin = greenArea[0];
1141     \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}  pixelMax = greenArea[0];
1142 
1143     \textcolor{keywordflow}{for}  (pixelIdx = 1;  pixelIdx < totPixels;  ++pixelIdx)
1144     \{
1145       \textcolor{keywordflow}{if}  ((!mask)  ||  (maskArea[pixelIdx] > maskTh))
1146       \{
1147         \textcolor{keywordflow}{if}  (greenArea[pixelIdx] < pixelMin)
1148           pixelMin = greenArea[pixelIdx];
1149 
1150         \textcolor{keywordflow}{if}  (greenArea[pixelIdx] > pixelMax)
1151           pixelMax = greenArea[pixelIdx];
1152       \}
1153     \}
1154 
1155     \textcolor{comment}{//kkint32  srcRange = pixelMax - pixelMin + 1;}
1156     \hyperlink{namespace_k_k_b_a791ebe73f89917067a7aab9dbd817e45}{VectorInt}  counts (256, 0);
1157 
1158     \textcolor{keywordflow}{for}  (pixelIdx = 0;  pixelIdx < totPixels;  ++pixelIdx)
1159     \{
1160       \textcolor{keywordflow}{if}  ((!mask)  ||  (maskArea[pixelIdx] > maskTh))
1161         counts[greenArea[pixelIdx]]++;
1162     \}
1163 
1164     \textcolor{keywordflow}{for}  (x = 0;  x < (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})counts.size ();  ++x)
1165     \{
1166       \textcolor{keywordflow}{if}  (counts[x] > 0)
1167       \{
1168         unI.push\_back (x);
1169         unICounts.push\_back (counts[x]);
1170       \}
1171     \}
1172   \}
1173 
1174   \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  nbins = (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})unI.size ();
1175 
1176   \textcolor{keywordflow}{if}  (nbins <= numClasses)
1177   \{
1178     \hyperlink{class_k_k_b_1_1_raster}{RasterPtr}  result = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_raster}{Raster} (srcImage->\hyperlink{class_k_k_b_1_1_raster_af8d10d15697d5b92fb9595c48b529feb}{Height} (), srcImage->
      \hyperlink{class_k_k_b_1_1_raster_aa2780c0b7ae75b7b595f99329689c1f6}{Width} (), \textcolor{keyword}{false});
1179     \textcolor{keywordflow}{for}  (x = 0;  x < nbins;  ++x)
1180     \{
1181       LabelRaster (result, mask, unI[x], x, srcImage);
1182     \}
1183     sep = 1;
1184     \textcolor{keyword}{delete}  srcImage;   
1185     srcImage = NULL;
1186     \textcolor{keywordflow}{return}  result;
1187   \}
1188 
1189   \hyperlink{namespace_k_k_b_a791ebe73f89917067a7aab9dbd817e45}{VectorInt}  histo  = unICounts;
1190   \hyperlink{namespace_k_k_b_a791ebe73f89917067a7aab9dbd817e45}{VectorInt}  pixval = unI;
1191 
1192   \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  P (histo.size (), 0.0);
1193   \textcolor{keywordflow}{for}  (x = 0;  x < (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})histo.size ();  ++x)
1194     P[x] = (\textcolor{keywordtype}{double})(histo[x]) / (\textcolor{keywordtype}{double})totMaskPixels;
1195 
1196   unI.clear ();
1197 
1198   \textcolor{comment}{//%% Zeroth- and first-order cumulative moments}
1199   \textcolor{comment}{//w = cumsum(P);}
1200   \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  w (P.size (), 0.0);
1201   w[0] = P[0];
1202   \textcolor{keywordflow}{for}  (x = 1;  x < (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})P.size (); ++x)
1203     w[x] = w[x - 1] + P[x];
1204 
1205   \textcolor{comment}{//mu = cumsum((1:nbins).*P);}
1206   \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  mu (P.size (), 0.0);
1207   mu[0] = 1.0 * P[0];
1208   \textcolor{keywordflow}{for}  (x = 1;  x < (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})P.size ();  ++x)
1209     mu[x] = mu[x - 1] + ((x + 1) * P[x]);
1210   \textcolor{keywordtype}{double}  muEnd = mu[mu.size () - 1];
1211   
1212   \textcolor{comment}{//%% Maximal sigmaB^2 and Segmented image}
1213   \textcolor{keywordflow}{if}  (numClasses == 2)
1214   \{
1215     \textcolor{comment}{//sigma2B =...}
1216     \textcolor{comment}{//    (mu(end) * w(2:end-1) - mu(2:end-1)) .^2  ./  w(2:end-1)./(1-w(2:end-1));}
1217     \textcolor{comment}{//    ------------------- P1 -----------------      ----------- P2 -----------}
1218     \textcolor{comment}{//[maxsig,k] = max(sigma2B);}
1219 
1220     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  wSubSet  = SubSet (w,  1, (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})w.size  () - 2);
1221     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  muSubSet = SubSet (mu, 1, (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})mu.size () - 2);
1222    
1223     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble} P1 = Power (Subt (muEnd * wSubSet, muSubSet), 2.0);
1224     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble} P2 = DotDiv (wSubSet, Subt (1.0, wSubSet));
1225     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble} sigma2B = DotDiv (P1, P2);
1226     \textcolor{keywordtype}{double}  maxSig = sigma2B[0];
1227     \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32} maxSigIdx = 0;
1228     \textcolor{keywordflow}{for}  (x = 1;  x < (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})sigma2B.size ();  ++x)
1229     \{
1230       \textcolor{keywordflow}{if}  (sigma2B[x] > maxSig)
1231       \{
1232         maxSig = sigma2B[x];
1233         maxSigIdx = x;
1234       \}
1235     \}
1236       
1237     \textcolor{comment}{//[maxsig,k] = max(sigma2B);}
1238     \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  k = maxSigIdx;
1239     
1240     \textcolor{comment}{//% segmented image}
1241     \textcolor{comment}{//IDX = ones(size(srcImage));}
1242     \textcolor{comment}{//IDX(srcImage>pixval(k+1)) = 2;}
1243     \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  threshold = pixval[k + 1];
1244     \hyperlink{class_k_k_b_1_1_raster}{RasterPtr}  result = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_raster}{Raster} (srcImage->\hyperlink{class_k_k_b_1_1_raster_af8d10d15697d5b92fb9595c48b529feb}{Height} (), srcImage->
      \hyperlink{class_k_k_b_1_1_raster_aa2780c0b7ae75b7b595f99329689c1f6}{Width} (), \textcolor{keyword}{false});
1245     \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  resultArea = result->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
1246     \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  srcArea    = srcImage->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
1247     \textcolor{keywordflow}{for}  (x = 0;  x < totPixels;  ++x)
1248     \{
1249       \textcolor{keywordflow}{if}  ((!maskArea)  ||  (maskArea[x] > maskTh))
1250       \{
1251         \textcolor{keywordflow}{if}  (srcArea[x] > threshold)
1252           resultArea[x] = 2;
1253         \textcolor{keywordflow}{else}
1254           resultArea[x] = 1;
1255       \}
1256       \textcolor{keywordflow}{else}
1257       \{
1258         resultArea[x] = 0;
1259       \}
1260     \}
1261     
1262     \textcolor{comment}{//% separability criterion}
1263     \textcolor{comment}{//sep = maxsig/sum(((1:nbins)-mu(end)).^2.*P);}
1264     \textcolor{keywordtype}{double}  sum = 0.0;
1265     \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  y = 0;
1266     muEnd = mu[mu.size () - 1];
1267     \textcolor{keywordflow}{for}  (x = 0, y = 1;  x < nbins;  ++x, ++y)
1268       sum = pow (((\textcolor{keywordtype}{double})y - muEnd), 2.0) * P[x];
1269 
1270     sep = maxSig / sum;
1271     \textcolor{keyword}{delete}  srcImage;
1272     srcImage = NULL;
1273     \textcolor{keywordflow}{return}  result;
1274   \}
1275     
1276   \textcolor{keywordflow}{if}  (numClasses == 3)
1277   \{
1278     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  w0 = w;
1279     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  w2 = FlipLeftRight (CumSum (FlipLeftRight (P)));
1280 
1281     \hyperlink{class_k_k_b_1_1_matrix}{Matrix} w0M ((\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})w0.size (), (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})w0.size ());
1282     \hyperlink{class_k_k_b_1_1_matrix}{Matrix} w2M ((\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})w2.size (), (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})w2.size ());
1283     NdGrid (w0, w2, w0M, w2M);
1284     
1285     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  mu0 = DotDiv (mu, w);
1286 
1287     \textcolor{comment}{//mu2 = fliplr(cumsum(fliplr((1:nbins).*P)) ./ cumsum(fliplr(P)));}
1288     \textcolor{comment}{//            1      2      34       4   32        3      4 321}
1289     \textcolor{comment}{//             ---------- P1 -------------     ------ P2 --------}
1290     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  P1 = CumSum (FlipLeftRight (DotMult (BDV (1.0, 1.0, (\textcolor{keywordtype}{double})nbins), P)));
1291     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  P2 = CumSum (FlipLeftRight (P));
1292     \hyperlink{namespace_k_k_b_a5906c207479607e5f450434095914a41}{VectorDouble}  mu2 = FlipLeftRight (DotDiv (P1, P2));
1293 
1294     \textcolor{comment}{//[mu0,mu2] = ndgrid(mu0,mu2);}
1295     \hyperlink{class_k_k_b_1_1_matrix}{Matrix}  mu0M ((\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})mu0.size (), (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})mu0.size ());
1296     \hyperlink{class_k_k_b_1_1_matrix}{Matrix}  mu2M ((\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})mu2.size (), (\hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32})mu2.size ());
1297     NdGrid (mu0, mu2, mu0M, mu2M);
1298     
1299     \textcolor{comment}{//w1 = 1-w0-w2;}
1300     \hyperlink{class_k_k_b_1_1_matrix}{Matrix}  w1M = 1.0 - w0M - w2M;
1301 
1302     \textcolor{comment}{//w1(w1<=0) = NaN;}
1303     MakeNanWhenLesOrEqualZero (w1M);
1304 
1305     \textcolor{comment}{//sigma2B =...}
1306     \textcolor{comment}{//    w0.*(mu0-mu(end)).^2 + w2.*(mu2-mu(end)).^2 +...}
1307     \textcolor{comment}{//    (w0.*(mu0-mu(end)) + w2.*(mu2-mu(end))).^2./w1;}
1308     \hyperlink{class_k_k_b_1_1_matrix}{Matrix}  P1M = (DotMult (w0M, Power ((mu0M - muEnd), 2.0)))  + (DotMult (w2M, Power ((mu2M - muEnd
      ), 2.0)));
1309     \hyperlink{class_k_k_b_1_1_matrix}{Matrix}  P2M = DotDiv (Power ((DotMult (w0M, (mu0M - muEnd)) +  DotMult (w2M, (mu2M - muEnd))), 2.
      0), w1M);
1310     \hyperlink{class_k_k_b_1_1_matrix}{Matrix}  sigma2B = P1M + P2M;
1311 
1312     \textcolor{comment}{//sigma2B(isnan(sigma2B)) = 0; % zeroing if k1 >= k2}
1313     ZeroOutNaN (sigma2B);
1314 
1315     \textcolor{comment}{//[maxsig,k] = max(sigma2B(:));         % Turns sigma2B into 1D Array then locates largest value and
       index.}
1316     \textcolor{comment}{// [k1,k2] = ind2sub([nbins nbins],k);  % Sets k1 and k2 to the indexes for k mapped into a 2D square
       matrix that is (nbins x nbins)}
1317     \hyperlink{namespace_k_k_b_a8fa4952cc84fda1de4bec1fbdd8d5b1b}{kkint32}  k1, k2;
1318     \textcolor{keywordtype}{double}  maxsig = 0.0;
1319     sigma2B.\hyperlink{class_k_k_b_1_1_matrix_ac4861e80e5f5f5a03bc61fd756538af5}{FindMaxValue} (maxsig, k1, k2);
1320    
1321     \textcolor{comment}{//% segmented image}
1322     \hyperlink{class_k_k_b_1_1_raster}{RasterPtr}  result = \textcolor{keyword}{new} \hyperlink{class_k_k_b_1_1_raster}{Raster} (srcImage->\hyperlink{class_k_k_b_1_1_raster_af8d10d15697d5b92fb9595c48b529feb}{Height} (), srcImage->
      \hyperlink{class_k_k_b_1_1_raster_aa2780c0b7ae75b7b595f99329689c1f6}{Width} (), \textcolor{keyword}{false});
1323     \{
1324       \textcolor{comment}{//IDX = ones(size(srcImage))*3;}
1325       \textcolor{comment}{//IDX(srcImage<=pixval(k1)) = 1;}
1326       \textcolor{comment}{//IDX(srcImage>pixval(k1) & srcImage<=pixval(k2)) = 2;}
1327       \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  srcData = srcImage->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
1328       \hyperlink{namespace_k_k_b_ace9969169bf514f9ee6185186949cdf7}{uchar}*  data = result->\hyperlink{class_k_k_b_1_1_raster_af6ceacfa7835a295d239d141627dbec7}{GreenArea} ();
1329       \textcolor{keywordtype}{double}  th1 = pixval[k1];
1330       \textcolor{keywordtype}{double}  th2 = pixval[k2];
1331       \textcolor{keywordflow}{for}  (x = 0;  x < totPixels;  ++x)
1332       \{
1333         \textcolor{keywordflow}{if}  ((!maskArea)  ||  (maskArea[x] > maskTh))
1334         \{
1335           \textcolor{keywordflow}{if}  (srcData[x] <= th1)
1336             data[x] = 1;
1337           \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}  (srcData[x] <= th2)
1338             data[x] = 2;
1339           \textcolor{keywordflow}{else}
1340             data[x] = 3;
1341         \}
1342         \textcolor{keywordflow}{else}
1343         \{
1344           data[x] = 0;
1345         \}
1346       \}
1347     \}
1348     
1349     sep = maxsig / Sum (DotMult (Power (Subt (BDV (1.0, 1.0, (\textcolor{keywordtype}{double})nbins), muEnd), 2.0), P));
1350     \textcolor{keyword}{delete}  srcImage;
1351     srcImage = NULL;
1352     \textcolor{keywordflow}{return}  result;
1353   \}
1354     
1355   \textcolor{keyword}{delete}  srcImage;
1356   srcImage = NULL;
1357     
1358   \textcolor{keywordflow}{return} NULL;
1359 \}  \textcolor{comment}{/* SegmentMaskedImage */}
\end{DoxyCode}
\index{K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}!Threshold1@{Threshold1}}
\index{Threshold1@{Threshold1}!K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}}
\subsubsection[{\texorpdfstring{Threshold1() const }{Threshold1() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uchar} K\+K\+B\+::\+Segmentor\+O\+T\+S\+U\+::\+Threshold1 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_k_k_b_1_1_segmentor_o_t_s_u_a84ba37425ca9e067fac8cf698729479b}{}\label{class_k_k_b_1_1_segmentor_o_t_s_u_a84ba37425ca9e067fac8cf698729479b}


Definition at line 98 of file Segmentor\+O\+T\+S\+U.\+h.


\begin{DoxyCode}
98 \{\textcolor{keywordflow}{return} threshold1;\}
\end{DoxyCode}
\index{K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}!Threshold2@{Threshold2}}
\index{Threshold2@{Threshold2}!K\+K\+B\+::\+Segmentor\+O\+T\+SU@{K\+K\+B\+::\+Segmentor\+O\+T\+SU}}
\subsubsection[{\texorpdfstring{Threshold2() const }{Threshold2() const }}]{\setlength{\rightskip}{0pt plus 5cm}{\bf uchar} K\+K\+B\+::\+Segmentor\+O\+T\+S\+U\+::\+Threshold2 (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{class_k_k_b_1_1_segmentor_o_t_s_u_a15d934ccfc4d73945877160f3c74b08b}{}\label{class_k_k_b_1_1_segmentor_o_t_s_u_a15d934ccfc4d73945877160f3c74b08b}


Definition at line 99 of file Segmentor\+O\+T\+S\+U.\+h.


\begin{DoxyCode}
99 \{\textcolor{keywordflow}{return} threshold2;\}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/\+Kurt/\+Git\+Hub/\+K\+Square\+Libraries/\+K\+K\+Base/\hyperlink{_segmentor_o_t_s_u_8h}{Segmentor\+O\+T\+S\+U.\+h}\item 
C\+:/\+Users/\+Kurt/\+Git\+Hub/\+K\+Square\+Libraries/\+K\+K\+Base/\hyperlink{_segmentor_o_t_s_u_8cpp}{Segmentor\+O\+T\+S\+U.\+cpp}\end{DoxyCompactItemize}
